<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>旅游博客/北京（摆烂式旅游）</title>
    <url>/2024/08/11/%E6%97%85%E6%B8%B8%E5%8D%9A%E5%AE%A2/%E5%8C%97%E4%BA%AC%EF%BC%88%E6%91%86%E7%83%82%E5%BC%8F%E6%97%85%E6%B8%B8%EF%BC%89/</url>
    <content><![CDATA[<p>旅行时间：7.11-7.17（7月10号中午到北京，晚上和同学吃饭，16号休息一天）  </p>
<p> 我是在江西长大的，有一说一对北京的美食并不是很提得起兴趣，但是对于北京烤鸭我还是绝对喜欢的。来北京吃烤鸭最有名的几个如四季民福、全聚德等，四季民福比全聚德相对来说便宜（对于我这个来自小城市的人来说人均200左右也不便宜了😅），有名的京菜有紫光园（价格很实惠）  </p>
<p>总的来说玩了一个礼拜，旅游景点顺序为[奥林匹克公园（鸟巢、水立方）-&gt;故宫博物馆-&gt;颐和园-&gt;天坛公园-&gt;慕田峪长城-&gt;天安门广场]，一天一个景点，主打一个随心所欲😀，不过很多都是提前需要预约的，需要提前规划好路线。  </p>
<table>
<thead>
<tr>
<th>景点</th>
<th>预约情况</th>
<th>价格</th>
</tr>
</thead>
<tbody><tr>
<td>奥林匹克公园</td>
<td>不需要预约</td>
<td>免费</td>
</tr>
<tr>
<td>故宫博物馆</td>
<td>需要预约，并且非常难抢，可以从美团、淘宝、咸鱼等方式购买旅游团中的个人票，多花钱</td>
<td>成人票80、学生票60</td>
</tr>
<tr>
<td>颐和园</td>
<td>需要预约，很好约</td>
<td>60元</td>
</tr>
<tr>
<td>天坛公园</td>
<td>需要预约，很好约，买联合票才能去祈年殿和回音壁</td>
<td>成人票34元、学生票17元</td>
</tr>
<tr>
<td>慕田峪长城</td>
<td>需要提前买票，可以买北京旅游集散的车票，直接从前门抵达旅游景点下方</td>
<td>车票+往返缆车票200元</td>
</tr>
<tr>
<td>天安门广场</td>
<td>需要提前预约，如果想要去天安门城楼和毛主席纪念堂需要提前买票，很难抢到票</td>
<td>免费</td>
</tr>
</tbody></table>
<h2 id="7-10刚来到酒店"><a href="#7-10刚来到酒店" class="headerlink" title="7.10刚来到酒店"></a>7.10刚来到酒店</h2><p>提前订好的酒店，在北京选酒店还是件挺难的事，考虑到交通、两个人住、住的时间长等问题，最后选在在北京四环附近的飘HOME酒店，双床房靠窗，448一晚，已经算比较实惠的了。交通上在14号线将台站附近，去所有景点大概都需要一个小时的通勤时间，只能折中处理了啊😜<br>[四季民福]<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E6%97%85%E6%B8%B8%E5%8D%9A%E5%AE%A2/%E5%8C%97%E4%BA%AC%EF%BC%88%E6%91%86%E7%83%82%E5%BC%8F%E6%97%85%E6%B8%B8%EF%BC%89/IMG_3376.jpg"></p>
<h2 id="7-11奥林匹克公园（鸟巢、水立方）"><a href="#7-11奥林匹克公园（鸟巢、水立方）" class="headerlink" title="7.11奥林匹克公园（鸟巢、水立方）"></a>7.11奥林匹克公园（鸟巢、水立方）</h2><p>为了拍夜景也是等了好久，大概八点多才开始亮灯，不过刚好后面几天是薛之谦在鸟巢开演唱会，晚上在彩排，也是听到最近很火的DJ版好像在哪里见过你（薛之谦彩排的时候可是唱了好几遍的😆）<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E6%97%85%E6%B8%B8%E5%8D%9A%E5%AE%A2/%E5%8C%97%E4%BA%AC%EF%BC%88%E6%91%86%E7%83%82%E5%BC%8F%E6%97%85%E6%B8%B8%EF%BC%89/IMG_3377.jpg"></p>
<h2 id="7-12故宫博物馆"><a href="#7-12故宫博物馆" class="headerlink" title="7.12故宫博物馆"></a>7.12故宫博物馆</h2><p>刚好遇见北京下大雨的天气，也真奇了怪，北京一年下不了几次雨还让我碰到了，虽然带了伞，但还是在去故宫博物馆的路上鞋子湿透了，不过刚好碰见下雨天气正好瞧见了故宫那强悍的排水系统，不得不佩服古代人在建筑上面的智慧了。可惜是阴雨天气，故宫建筑里面很多是进不去的，光线也不好，不能很好的看到皇帝坐的椅子，也发挥不了皇帝坐在殿堂上与大臣们开会的想象了🤔。不过逛了逛旁边太后们住的地方，感受下慈禧太后的花园，还是挺有历史气息的😋。<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E6%97%85%E6%B8%B8%E5%8D%9A%E5%AE%A2/%E5%8C%97%E4%BA%AC%EF%BC%88%E6%91%86%E7%83%82%E5%BC%8F%E6%97%85%E6%B8%B8%EF%BC%89/IMG_3378.jpg"></p>
<h2 id="7-13颐和园"><a href="#7-13颐和园" class="headerlink" title="7.13颐和园"></a>7.13颐和园</h2><p>颐和园公园还是挺大的，主要是还有一个昆明湖，转一圈下来很考验我的双腿🦵，坐了小船，爬了小山，感受一下皇帝们的避暑娱乐的场所，还是觉得古代皇帝才是最快乐的🤣。<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E6%97%85%E6%B8%B8%E5%8D%9A%E5%AE%A2/%E5%8C%97%E4%BA%AC%EF%BC%88%E6%91%86%E7%83%82%E5%BC%8F%E6%97%85%E6%B8%B8%EF%BC%89/IMG_3379.jpg"></p>
<h2 id="7-14天坛公园"><a href="#7-14天坛公园" class="headerlink" title="7.14天坛公园"></a>7.14天坛公园</h2><p>天坛公园有一个很大的特色，很多老人来这休闲娱乐，这里对于60岁以上老人是免费开放的，这也导致一个问题：这个公园我去参观的时候人很多啊🥵。到祈年殿那里人特别的多，根本没有很好的拍照点；回音壁那里如果人不多吼一嗓子是真的有回声的，但是人多了就没有了，难受😭。去天坛就是为了打卡这个高考数学题上出现了几次的地方🤣<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E6%97%85%E6%B8%B8%E5%8D%9A%E5%AE%A2/%E5%8C%97%E4%BA%AC%EF%BC%88%E6%91%86%E7%83%82%E5%BC%8F%E6%97%85%E6%B8%B8%EF%BC%89/IMG_3380.jpg"></p>
<h2 id="7-15慕田峪长城（city不city啊）"><a href="#7-15慕田峪长城（city不city啊）" class="headerlink" title="7.15慕田峪长城（city不city啊）"></a>7.15慕田峪长城（city不city啊）</h2><p>主要是北京有两处长城的旧址：八达岭长城和慕田峪长城。也是搜集了很多攻略，看了很多评价，主要是刚好去长城是暑假中的星期一，星期一其他旅游景点闭馆，这样导致了长城的游客特别多，尤其是八达岭长城（毕竟八达岭长城比慕田峪长城更有名气），八达岭长城拍照更壮观，慕田峪长城人会更少一点，看旅游所需，由于身边带了个老人出来旅游，只爬了一下段长城（好汉坡啥的都没去），主要是为了打卡“不到长城非好汉”😋<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E6%97%85%E6%B8%B8%E5%8D%9A%E5%AE%A2/%E5%8C%97%E4%BA%AC%EF%BC%88%E6%91%86%E7%83%82%E5%BC%8F%E6%97%85%E6%B8%B8%EF%BC%89/IMG_3381.jpg"></p>
<h2 id="7-17天安门广场"><a href="#7-17天安门广场" class="headerlink" title="7.17天安门广场"></a>7.17天安门广场</h2><p>天安门广场给人最大的印象就是国家阅兵那浩荡的气势，广场确实很宽广，旁边就是人民大会堂和国家博物馆，前面是人民英雄纪念碑和毛主席纪念堂，再加上武警的站岗给人一种很庄严、严肃的感觉，不愧是国家首都必打卡的地方。<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E6%97%85%E6%B8%B8%E5%8D%9A%E5%AE%A2/%E5%8C%97%E4%BA%AC%EF%BC%88%E6%91%86%E7%83%82%E5%BC%8F%E6%97%85%E6%B8%B8%EF%BC%89/IMG_3382.jpg"></p>
<h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>旅游的时间太久了，最后还是会给人一种疲劳，不过我们一天一个旅游景点，在旅游过程中还是很养精蓄锐的，每次去到这些景点还是活气十足，人生中怎么说都要来一次首都参观，感受中国最大的魅力。</p>
]]></content>
      <categories>
        <category>旅游博客</category>
      </categories>
  </entry>
  <entry>
    <title>第一章-线性表（有时间补充含有头结点和不含有头结点的链表插入删除操作）</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88%E6%9C%89%E6%97%B6%E9%97%B4%E8%A1%A5%E5%85%85%E5%90%AB%E6%9C%89%E5%A4%B4%E7%BB%93%E7%82%B9%E5%92%8C%E4%B8%8D%E5%90%AB%E6%9C%89%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%EF%BC%89/</url>
    <content><![CDATA[<p>定义：具有相同数据类型的n（n&gt;&#x3D;0）个数据元素的有限序列.<br><code>线性表是一种逻辑结构，表示元素之间的一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念。</code></p>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>定义：线性表的顺序存储，它是用一组地址连续的存储单元依此存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。<code>逻辑顺序与物理顺序相同</code>。</p>
<h4 id="存储结构体（静态）"><a href="#存储结构体（静态）" class="headerlink" title="存储结构体（静态）"></a>存储结构体（静态）</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MaxSize 50           //定义线性表的最大长度</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	ElemType data[MAxSize];  //顺序表的元素</span><br><span class="line">	int length;              //顺序表的当前长度</span><br><span class="line">&#125;Sqlist;                     //顺序表的类型定义</span><br></pre></td></tr></table></figure></div>
<h4 id="存储结构体（动态）"><a href="#存储结构体（动态）" class="headerlink" title="存储结构体（动态）"></a>存储结构体（动态）</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define InitSize 100     //表长度的初始定义</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	ElemType *data;      //指示动态分配数组的指针</span><br><span class="line">	int MAxSize,length;  //数组的最大容量和当前个数</span><br><span class="line">&#125;SeqList;                //动态分配数组顺序表的类型定义</span><br></pre></td></tr></table></figure></div>
<p><code>动态分配并不是链式存储，它同样属于顺序存储结构，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时动态决定。</code></p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>随机访问</strong>，通过首地址和元素序号可在时间O(1)内找到指定的元素；</li>
<li>存储密度高，每个节点只存储数据元素；</li>
<li>插入和删除需要移动大量元素。</li>
</ul>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool ListInsert( Sqlist &amp;L,int i,ElemType e )&#123;</span><br><span class="line">	if( i &lt; 1 || i &gt; L.length + 1)       //判断i的范围是否有效</span><br><span class="line">		return false;</span><br><span class="line">	if( L.length &gt;= MaxSize )            //当前存储空间已满，不能插入</span><br><span class="line">		return false;</span><br><span class="line">	for( int j = L.length; j &gt;= i; j--)  //将第i个元素及之后的元素后移</span><br><span class="line">		L.data[j] = L.data[j-1];</span><br><span class="line">	L.data[i-1] = e;                     //在位置i处放入e</span><br><span class="line">	L.length++;                          //线性表长度加1</span><br><span class="line">	return ture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>平均时间复杂度为O(n)</p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool ListDelete(SqList &amp;L,int i,ElemType &amp;e)&#123;</span><br><span class="line">	if(i&lt;1||i&gt;L.length)          //判断i的范围是否有效</span><br><span class="line">		return false;</span><br><span class="line">	e = L.data[i-1];             //将被删除的元素赋值给e</span><br><span class="line">	for(int j=i;j&lt;L.length;j++)  //将第i个元素后的元素前移</span><br><span class="line">		L.data[j-1] = L.data[j];</span><br><span class="line">	L.length--;                  //线性表长度减1</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>平均时间复杂度为O(n)</p>
<h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">int LocateElem(SqList L,ElemType e)&#123;</span><br><span class="line">	inty i;</span><br><span class="line">	for(i=0;i&lt;L.length;i++)</span><br><span class="line">		if(L.data[i]==e)</span><br><span class="line">			return i+1;  //下标为i的元素值等于e，返回其位序i+1</span><br><span class="line">	return 0;            //退出循环，说明查找失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>平均时间复杂度为O(n)</p>
<h3 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>定义：线性表的链式存储，通过一组任意的存储单元来存储线性表中的数据元素。</p>
<h5 id="存储结构体"><a href="#存储结构体" class="headerlink" title="存储结构体"></a>存储结构体</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct LNode&#123;    //定义单链表结点类型</span><br><span class="line">	ElemType data;       //数据域</span><br><span class="line">	struct LNode *next;  //指针域</span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure></div>
<p>头结点的优点：</p>
<ul>
<li>由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的 操作和在表的其他位置上的操作一致，无须进行特殊处理。</li>
<li>无论链表是否为空，其头指针都指向头结点的非空指针（空表中头结点的指针域为空）， 因此空表和非空表的处理也就得到了统一。</li>
</ul>
<h5 id="头插法建立单链表（存在头指针）"><a href="#头插法建立单链表（存在头指针）" class="headerlink" title="头插法建立单链表（存在头指针）"></a>头插法建立单链表（存在头指针）</h5><p><code>生成链表中的节点次序和输入数据的顺序一致</code><br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88%E6%9C%89%E6%97%B6%E9%97%B4%E8%A1%A5%E5%85%85%E5%90%AB%E6%9C%89%E5%A4%B4%E7%BB%93%E7%82%B9%E5%92%8C%E4%B8%8D%E5%90%AB%E6%9C%89%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%EF%BC%89/List_HeadInsert.png"></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LinkList List_HeadInsert(LinkList &amp;L)&#123;      //逆向建立单链表</span><br><span class="line">	LNode *s;</span><br><span class="line">	int x;</span><br><span class="line">	L = (LinkList)malloc(sizeof(LNode));    //创建头节点</span><br><span class="line">	L-&gt;next = NULL;                         //初始为空链表</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;x);                         //输入节点的值</span><br><span class="line">	while(x!=9999)&#123;                         //输入9999表示结束</span><br><span class="line">		s = (LNode*)malloc(sizeof(LNode));  //创建新的节点</span><br><span class="line">		s-&gt;data = x;</span><br><span class="line">		s-&gt;next = s;                        //将新节点插入表中，L为头指针</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">	&#125;</span><br><span class="line">	return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>平均时间复杂度O(n)</p>
<h5 id="尾插法建立单链表"><a href="#尾插法建立单链表" class="headerlink" title="尾插法建立单链表"></a>尾插法建立单链表</h5><p><code>生成链表中的节点次序和输入数据的顺序一致</code><br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88%E6%9C%89%E6%97%B6%E9%97%B4%E8%A1%A5%E5%85%85%E5%90%AB%E6%9C%89%E5%A4%B4%E7%BB%93%E7%82%B9%E5%92%8C%E4%B8%8D%E5%90%AB%E6%9C%89%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%EF%BC%89/List_TailInsert.png"></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LinkList List_TailInsert(LinkList &amp;L)&#123;  //正向建立单链表</span><br><span class="line">	int x;                              //设元素类型为整型</span><br><span class="line">	L = (LinkList)malloc(sizeof(LNode));</span><br><span class="line">	LNode *s,*r = L;                    //r为表尾指针</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;x);                     //输入结点的值</span><br><span class="line">	while(x!=9999)&#123;                     //输入9999表示结束</span><br><span class="line">		s = (LNode *)malloc(sizeof(LNode));</span><br><span class="line">		s-&gt;data = x;</span><br><span class="line">		r-&gt;next = s;</span><br><span class="line">		r = s;                          //r指向新的表尾节点</span><br><span class="line">		scanf(&quot;%d,&amp;x);</span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next = NULL;                     //尾结点指针置空</span><br><span class="line">	return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>平均时间复杂度O(n)</p>
<h5 id="按序号查找结点"><a href="#按序号查找结点" class="headerlink" title="按序号查找结点"></a>按序号查找结点</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LNode *GetElem(LinkList L,int i)&#123;</span><br><span class="line">	int j=1;             //计数，初始为1</span><br><span class="line">	LNode *p = L-&gt;next;  //第一个结点指针赋给p</span><br><span class="line">	if(i==0) return L;   //若i等于0，则返回头结点</span><br><span class="line">	if(i&lt;1) return NULL; //若i无效，则返回头结点</span><br><span class="line">	while(p&amp;&amp;j&lt;i)&#123;       //从第1个节点开始找，查找第i个结点</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	return p;            //返回第i个结点的指针，若i大于表长，则返回NULL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>平均时间复杂度O(n)</p>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>由于单链表只有一个指向后继的指针，使得单链表只能从头结点依次顺序向后遍历则导致访问前驱节点只能从头遍历，时间复杂度为O(n)，为了克服这个缺点，从而引入双链表，双链表每个节点存在两个指针prior和next，分别指向前驱节点和后继节点。</p>
<h5 id="存储结构体-1"><a href="#存储结构体-1" class="headerlink" title="存储结构体"></a>存储结构体</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct DNode&#123;           //定义双链表节点类型</span><br><span class="line">	ElemType data;              //数据域</span><br><span class="line">	struct DNode *prior,*next;  //前驱和后继指针</span><br><span class="line">&#125;DNode,*DLinkList;</span><br></pre></td></tr></table></figure></div>
<p><code>注意：进行插入删除操作需要同时改变前驱指针和后继指针</code></p>
<h4 id="循环单链表和循环双链表"><a href="#循环单链表和循环双链表" class="headerlink" title="循环单链表和循环双链表"></a>循环单链表和循环双链表</h4><p>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL,而改为指向头结点, 从而整个链表形成一个环。<br><code>对循环单链表设置尾指针效率会更高</code><br><code>循环双链表为空时，头结点的前驱和后继都是本身</code></p>
<h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p>静态链表借助数组来描述线性表的链式存储结构（指针是结点的相对地址（数组下标），也称为游标）</p>
<h5 id="存储结构体-2"><a href="#存储结构体-2" class="headerlink" title="存储结构体"></a>存储结构体</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MaxSize 50  //静态链表的最大长度</span><br><span class="line">typedef struct &#123;    //静态链表结构类型的定义</span><br><span class="line">	ElemType data;  //存储数据元素</span><br><span class="line">	int next;       //下一个元素的数组下标</span><br><span class="line">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure></div>
<h3 id="顺序存储和链式存储的比较"><a href="#顺序存储和链式存储的比较" class="headerlink" title="顺序存储和链式存储的比较"></a>顺序存储和链式存储的比较</h3><ul>
<li>存取（读写方式）<ul>
<li>顺序存储：可以顺序存取，也可以随机存取；</li>
<li>链式存储：只能从表头顺序存取元素。</li>
</ul>
</li>
<li>逻辑结构与物理结构<ul>
<li>顺序存储：逻辑上相邻的元素，对应的物理存储位置也相邻 ；</li>
<li>链式存储：逻 辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的。</li>
</ul>
</li>
<li>查找、插入和删除操作<ul>
<li>顺序存储：<ul>
<li>按值查找： <ul>
<li>无序：时间复杂度O(n)</li>
<li>有序：最快时间复杂度O(log(n))</li>
</ul>
</li>
<li>按序号查找：随机访问 O(1)</li>
<li>插入、删除：平均需要移动半个表长的元素</li>
</ul>
</li>
<li>链式存储：存储密度不大，平均时间复杂度O(n) ，插入删除只需要修改相关节点的指针域。</li>
</ul>
</li>
<li>空间分配：<ul>
<li>顺序存储<ul>
<li>静态：预先分配预先大量空间 ，容易造成内存溢出；</li>
<li>动态：需要移动大量元素，操作效率降低</li>
</ul>
</li>
<li>链式存储：操作灵活高效</li>
</ul>
</li>
</ul>
<h3 id="如何选取存储结构"><a href="#如何选取存储结构" class="headerlink" title="如何选取存储结构"></a>如何选取存储结构</h3><ol>
<li>基于存储考虑：难以估计存储规模或者长度，选择链式存储；</li>
<li>基于运算考虑：根据序号查找选择顺序存储，插入删除操作选择链式存储；</li>
<li>基于环境考虑：顺序存储比较稳定，但如果需要频繁进行插入删除等操作更改元素选择链式存储（动态性较强）</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>第四章-树</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%A0%91/</url>
    <content><![CDATA[<p>定义：有且仅有一个特定的成为根的节点，存在n（n&gt;1）个节点时，其余节点可分为m个互不相交的有限集，每个集合又是树。<br><em>树的定义是递归的，树是一种递归的数据结构，树作为一种逻辑结构，同时也是一种分层结构</em></p>
<hr>
<h1 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h1><ul>
<li>从根节点A到结点K的唯一路径上的任意节点成为K的祖先。路径上最接近结点K的结点E称为K的双亲。拥有相同双亲的节点称为兄弟。</li>
<li>树中的一个结点的孩子个数称为该结点的度，树中结点的最大度数称为树的度。</li>
<li>度大于0的结点称为分支节点；度为0的结点称为叶节点</li>
<li>结点的层次从树根开始定义，根节点为第一层，它的子结点为第2层，以此类推。双亲在同一层的结点互为堂兄弟</li>
<li>结点的深度是从根节点开始自顶向下逐层累加</li>
<li>结点的高度是从叶节点开始自底向上逐层累加</li>
<li>树中结点的各子树从左到右是有次序的，不能互换，称为有序树；反之称为无序树</li>
<li>树中两个结点之间的路径是由这两个节点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数</li>
<li>森林是m棵互不相交的树的集合，把树的根节点删去就变成了森林</li>
</ul>
<hr>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树是有序树，可以为空二叉树或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树同样也必须为二叉树。<br>二叉树与度为2的有序树的区别：</p>
<ul>
<li>度为2的树至少有三个节点，而二叉树可以为空</li>
<li>度为2的有序树的孩子的左右次序是相对于另一个孩子而言的，若某个结点只有一个孩子，则这个孩子就无需区分其左右次序，而二叉树无论其孩子是否为2，均需确定其左右次序，即二叉树的结点次序不是相对于另一个节点而言的，而是确定的。</li>
</ul>
<hr>
<h2 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h2><ol>
<li>满二叉树：一棵高度为h，且含有$2^h-1$个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点。</li>
<li>完全二叉树：高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应。<ol>
<li>若$i\leq[n&#x2F;2]$,则结点i为分支结点，否则为叶节点</li>
<li>叶结点只可能出现在层次最大的两层上出现。对于最大层次中的叶结点，则依次排列在该层最左边的位置上</li>
<li>若有度为1的结点，则只可能有一个，并且该结点只有左孩子而没有右孩子</li>
<li>按层序编号后，一旦出现某结点（编号为i）为叶结点或只有左孩子，则编号大于i的结点均为叶结点</li>
<li>若n为奇数，则每个分支节点都有左孩子和右孩子；若n为偶数，则编号最大的分支结点（编号为n&#x2F;2）只有左孩子，没有右孩子，其余分支结点左、右孩子都有</li>
</ol>
</li>
<li>二叉排序树：左子树上所有结点的关键字均小于根节点的关键字；右子树上的所有结点的关键字均大于根节点的关键字；左子树和右子树又各是一棵二叉排序树</li>
<li>平衡二叉树：树上任意一个结点的左子树和右子树的深度之差不超过1</li>
</ol>
<hr>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ol>
<li>非空二叉树上的叶结点等于度为2的结点数加1，即$n_0&#x3D;n_2+1$</li>
<li>非空二叉树第k层上至多有$2^{k-1}$个结点</li>
<li>高度为h的二叉树至多有$2^h-1$个结点</li>
<li>对完全二叉树按从上到下、从左到右的顺序依次编号1，2，3···，n，则有以下关系：<ol>
<li>当i&gt;1时，结点i的双亲的编号为【i&#x2F;2】，即当i为偶数时，其双亲的编号为i&#x2F;2，它是双亲的左孩子；当i为奇数时，其双亲的编号为（i-1）&#x2F;2，它是双亲的右孩子。</li>
<li>当2i$\leq$n时，结点i的左孩子编号为2i，否则无左孩子；当2i+1$\leq$n时，结点i的右孩子编号为2i+1，否则无右孩子；</li>
<li>结点i所在的层次为【$log_2i$】+1</li>
</ol>
</li>
<li>具有n个结点的完全二叉树的高度为【$log_{2}(n+1)$】或【$log_{2}(n)$】+1</li>
</ol>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h2 id="二叉树的顺序存储是指用一组地址连续的存储单元依此从上而下、从左至右存储完全二叉树上的结点元素（完全二叉树和满二叉树采用顺序存储比较合适）；对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中。"><a href="#二叉树的顺序存储是指用一组地址连续的存储单元依此从上而下、从左至右存储完全二叉树上的结点元素（完全二叉树和满二叉树采用顺序存储比较合适）；对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中。" class="headerlink" title="  二叉树的顺序存储是指用一组地址连续的存储单元依此从上而下、从左至右存储完全二叉树上的结点元素（完全二叉树和满二叉树采用顺序存储比较合适）；对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中。    
  "></a>  二叉树的顺序存储是指用一组地址连续的存储单元依此从上而下、从左至右存储完全二叉树上的结点元素（完全二叉树和满二叉树采用顺序存储比较合适）；对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中。    
  </h2><pre><code>二叉链表的链式存储结构：
</code></pre>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct BiNode&#123;</span><br><span class="line">	ElemType data;                   //数据域</span><br><span class="line">	struct BiTNode *lchild,*rchild;  //左、右孩子指针</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure></div>
<p><code>在含有n个结点的二叉链表中含有n+1个空链域</code></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>第三章-串</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E4%B8%B2/</url>
    <content><![CDATA[<p>定义：由零个或多个字符组成的有限序列。记为S&#x3D;‘a1a2······an’，n&#x3D;0时称为空串。<br>串中任意多个连续的字符组成的子序列称为该串的<code>子串</code>，包含子串的串称为<code>主串</code>。<br>当两个串的长度相等且每个对应位置的字符都相等时，称两个串是相等的。<br><code>串的逻辑结构和线性表极为相似，区别仅在于串的数据对象限定为字符集。</code></p>
<h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><h4 id="定长顺序存储表示"><a href="#定长顺序存储表示" class="headerlink" title="定长顺序存储表示"></a>定长顺序存储表示</h4><p>用一组地址连续的存储单元来存储串值的字符序列。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAXLEN 255    //预定义最大串长为255</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	char ch[MAXLEN];  //每个分量存储一个字符</span><br><span class="line">	int length;       //串的实际长度</span><br><span class="line">&#125;SString</span><br></pre></td></tr></table></figure></div>
<p>串的实际长度只能小于或等于MAXLEN，超过预定义长度的串值会被舍去，称为<code>截断</code>.</p>
<h4 id="堆分配存储表示"><a href="#堆分配存储表示" class="headerlink" title="堆分配存储表示"></a>堆分配存储表示</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">	char *ch;     //按串长分配存储区，ch指向串的基地址</span><br><span class="line">	int length;   //串的长度</span><br><span class="line">&#125;HString</span><br></pre></td></tr></table></figure></div>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>StrAssign (&amp;T, chars):赋值操作。把串T赋值为 chars。</li>
<li>StrCopy (&amp;T,S):复制操作。由串S复制得到串T。</li>
<li>StrEmpty (S):判空操作。若S为空串，则返回TRUE,否则返回FALSE。</li>
<li>StrCompare (S,T):比较操作。若S&gt;T,则返回值&#x3D;0；若S&#x3D;T,则返回值&#x3D;0；若S&lt;T, 则返回值&lt;0。</li>
<li>StrLength (S):求串长。返回串S的元素个数。</li>
<li>SubString (&amp;Sub, S, pos, len):求子串。用Sub返回串S的第pos个字符起长度为 len的子串。</li>
<li>Concat (&amp;T,S1,S2)：串联接。用T返回由S1和S2联接而成的新串。</li>
<li>Index(S,T):定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0。</li>
<li>ClearString (&amp;S):清空操作。将S清为空串。</li>
<li>DestroyString (&amp; S)：销毁串。将串 S 销毁。</li>
</ul>
<h3 id="简单模式匹配"><a href="#简单模式匹配" class="headerlink" title="简单模式匹配"></a>简单模式匹配</h3><p>子串的定位操作通常称为串的模式匹配，他求的是子串（模式串）在主串中的位置，以下给出暴力匹配算法。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Index(SString S,SString T)&#123;</span><br><span class="line">	int i=1,j=1;</span><br><span class="line">	while(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">		if(S.ch[i] == T.ch[j])&#123;</span><br><span class="line">			++i;++j;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			i=i-j+2;j=1</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(j&gt;T.length) return i-T.length;</span><br><span class="line">	else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//得到部分匹配表next[]</span><br><span class="line">void get_next(SString T,int next[])&#123;</span><br><span class="line">	int i=1,j=0;                     //i是字符串遍历索引；j是与后缀匹配长度的索引</span><br><span class="line">	next[1]=0;</span><br><span class="line">	while(i&lt;T.length)&#123;</span><br><span class="line">		if(j==0||T.ch[i] == T.ch[j])&#123;//先评判前面是否存在匹配长度，不存在则i所指的位置的匹配长度j重新回到头部位置；若存在则继续评判该i位置元素是否与前面匹配成功的长度的位置j元素是否相等，如果相等，则i下一个元素的后缀匹配长度为j，但是部分匹配成功索引需要对该长度位置的下一个位置进行比对，所以next对应的元素应该为长度加1；不相等，则回到成功匹配长度位置所对应的next元素进行比对。</span><br><span class="line">			++i;++j;</span><br><span class="line">			next[i]=j;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			j=next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Index_KMP(SString S,SString T,int next[])&#123;</span><br><span class="line">	int i=1,j=1;</span><br><span class="line">	while(i&lt;=S.length&amp;&amp;j&lt;=T.length)&#123;</span><br><span class="line">		if(j==0||S.ch[i]==T.ch[i])&#123;</span><br><span class="line">			++i;++j;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			j=next[j];</span><br><span class="line">		&#125;</span><br><span class="line">		if(j&gt;T.length) return i-T.length;</span><br><span class="line">		else return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>KMP算法时间复杂度为O(m+n),KMP算法仅在主串与子串有很多“部分匹配”是才显得比普通算法快得多</p>
<h3 id="KMP算法优化"><a href="#KMP算法优化" class="headerlink" title="KMP算法优化"></a>KMP算法优化</h3><p>当相同字符在字符串中连续不间断出现很多次时，需要改进next数组，只需要添加多一个判断进行判断当前位置是否与匹配长度位置是否相等。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">void get_nextval(SString T,int nextval[])</span><br><span class="line">&#123;</span><br><span class="line">	int i=1;j=0;</span><br><span class="line">	nextval[1]=0;</span><br><span class="line">	while(i&lt;T.length)&#123;</span><br><span class="line">		if(j==0||T.ch[i]==T.ch[j])&#123;</span><br><span class="line">			++i;++j;</span><br><span class="line">			if(T.ch[i]!=T.ch[j]) nextval[i]=j;</span><br><span class="line">			else nextval[i]=nextval[j];</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			j=nextval[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络体系结构</title>
    <url>/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><strong>计算机网络</strong>：是一个将众多分散的、自治的计算机系统，通过通信设备与线路连接，有功能完整的软件实现资源共享和信息传递的系统。<br><strong>互连网</strong>：可以把两个或多个计算机网络互相连接起来，形成更大的计算机网络。<code>任意协议</code><br><strong>互联网（Internet）</strong>：由各大ISP（Internet Service Provider）和国际机构组建的，覆盖全球范围的互连网。<code>TCP/IP协议</code><br><code>家用路由器=路由器+交换机+其他功能</code></p>
<h2 id="计算机网络组成"><a href="#计算机网络组成" class="headerlink" title="计算机网络组成"></a>计算机网络组成</h2><ul>
<li>从组成部分来看：<ul>
<li>硬件：<ul>
<li>主机</li>
<li>通信链路</li>
<li>交互设备</li>
<li>通信处理机</li>
<li>······</li>
</ul>
</li>
<li>软件：方便用户使用，实现资源共享</li>
<li>协议：规定了计算机网络中的通信规则，由硬件、软件共同实现。</li>
</ul>
</li>
<li>从工作方式来看：<ul>
<li>边缘部分：<ul>
<li>工作方式：直接为用户服务</li>
<li>主要由连接到互联网上的主机及其软件组成</li>
</ul>
</li>
<li>核心部分：<ul>
<li>工作方式：为边缘部分提供服务</li>
<li>由大量网络和连接这些网络的路由器组成</li>
</ul>
</li>
</ul>
</li>
<li>从逻辑功能来看：<ul>
<li>通信子网：<ul>
<li>计算机网络中负责计算机间信息信息传输的部分。即把计算机和其他用户装置互联在一起的所有通信设备和介质的总称</li>
<li>主要由通信链路+通信设备+协议构成</li>
</ul>
</li>
<li>资源子网：<ul>
<li>计算机网络运行应用程序，向用户提供可共享的硬件、软件和信息资源的部分</li>
<li>主要由连接到互联网上的主机组成</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h2><ul>
<li>资源共享：<ul>
<li>硬件资源共享</li>
<li>软件资源共享</li>
<li>数据资源共享</li>
</ul>
</li>
<li>数据通信：实现计算机之间的数据传输。<em>最基本最重要的功能</em></li>
<li>分布式处理：将某个复杂任务分配给网络中多台计算机处理</li>
<li>提高可靠性：网络中各台计算机互为替代机</li>
<li>负载均衡：将工作任务均衡地分配给计算机网络中的各台计算机</li>
<li>还可以实现电子化办公与服务、远程教育、娱乐等功能</li>
</ul>
<h2 id="电路交换、报文交换与分组交换"><a href="#电路交换、报文交换与分组交换" class="headerlink" title="电路交换、报文交换与分组交换"></a>电路交换、报文交换与分组交换</h2><p><strong>电路交换</strong>：通过物理线路的连接，动态地分配传输线路资源<br>优点：</p>
<ul>
<li>通信钱从主叫端到被叫端建立一条专用的物理线路，在通信的全部时间内，两个用户始终占用端到端的线路资源。数据直送，传输速率高。<code>更适用于：低频次、大量地传输数据</code></li>
</ul>
<p>缺点：</p>
<ul>
<li>建立&#x2F;释放连接，需要额外的时间开销</li>
<li>线路被通信双方独占，利用率低</li>
<li>线路分配的灵活性差</li>
<li>交换节点不支持“差错控制”（无法发现传输过程中发生的数据错误）</li>
</ul>
<p><strong>报文交换</strong>：存储转发交换<br>优点：</p>
<ul>
<li>通信前无需建立连接</li>
<li>数据以“报文”为单元被交换节点间“存储转发”，通信线路可以灵活分配</li>
<li>在通信时间内，两个用户无需独占一整条物理线路。相比于电路交换，线路利用率高</li>
<li>支持“差错控制”（通过校验技术）</li>
</ul>
<p>缺点：</p>
<ul>
<li>报文不定长，不方便存储管理</li>
<li>长报文的·存储转发时间开销大、缓存开销大</li>
<li>长报文容易出错，重传的代价高</li>
</ul>
<p><strong>分组交换</strong>：将用户的信息划分为一定长度的数据分组，然后在分组数据上加上控制信息和地址，然后经过分组交换机发送到目的地址。<br>优点：</p>
<ul>
<li>通信前无需建立连接</li>
<li>数据以“分组”为单元被交换结点间“存储转发”，通信线路可以灵活分配</li>
<li>在通信时间内，两个用户无需独占一整条物理线路。相比于电路交换，线路利用率高</li>
<li>支持“差错控制”（通过校验技术）</li>
</ul>
<p>改进问题：（相对于报文交换）</p>
<ul>
<li>分组定长，方便存储转发管理</li>
<li>分组的存储转发时间开销小、缓存开销小</li>
<li>分组不易出错、重传代价低</li>
</ul>
<p>缺点：</p>
<ul>
<li>控制信息占比增加（）</li>
<li>存在转发时延</li>
<li>报文被拆分成多个分组，传输过程中可能出现失序、丢失等问题，增加处理的复杂度<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Three_Net.png"></li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>电路交换</th>
<th>报文交换交换</th>
<th>分组交换</th>
</tr>
</thead>
<tbody><tr>
<td>完成传输所需时间</td>
<td>最少</td>
<td>最多</td>
<td>较少</td>
</tr>
<tr>
<td>存储转发时延</td>
<td>无</td>
<td>较高</td>
<td>较低</td>
</tr>
<tr>
<td>通信前是否需要建立连接</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>缓存开销</td>
<td>无</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>是否支持差错控制</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>报文数据是否有序到达</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否需要额外的控制信息</td>
<td>否</td>
<td>是</td>
<td>是（控制信息占比较大）</td>
</tr>
<tr>
<td>线路分配的灵活性</td>
<td>不灵活</td>
<td>灵活</td>
<td>非常灵活</td>
</tr>
<tr>
<td>线路利用率</td>
<td>低</td>
<td>高</td>
<td>非常高</td>
</tr>
</tbody></table>
<h2 id="计算机网路的分类"><a href="#计算机网路的分类" class="headerlink" title="计算机网路的分类"></a>计算机网路的分类</h2><ul>
<li>按分布范围分类：<ul>
<li>广域网（WAN）：一般跨国跨省</li>
<li>城域网（MAN）：跨城市，常采用“以太网技术”</li>
<li>局域网（LAN）：跨学校&#x2F;企业&#x2F;工作单位&#x2F;家庭，<strong>“以太网技术”</strong></li>
<li>个域网（PAN）：个人家庭使用，经常被称为“无线个域网”</li>
</ul>
</li>
<li>按传输技术分类：<ul>
<li>广播式网络：当一台计算机发送数据分组时，广播范围内所有计算机都会收到该分组，并通过检查分组的目的地址决定是否接受该分组</li>
<li>点对点网络：数据只会从发送方“点对点”发到接收方，精准送达</li>
</ul>
</li>
<li>按拓扑结构：<ul>
<li>总线型结构：数据”广播式“传输；存在”总线争用“</li>
<li>环形结构：数据”广播式“传输；通过”令牌“解决总线争用问题，令牌顺环形依次传递，拿到令牌者可使用总线</li>
<li>星型结构：由中央设备实现数据的”点对点“传输，不存在”总线争用“问题</li>
<li>网状结构：数据通过各中间节点逐一存储转发，属于”点到点“传输，常见于”广域网“，灵活、可靠性高但是复杂性也高</li>
</ul>
</li>
<li>按使用者分类：<ul>
<li>公用网：向公众开放的网络</li>
<li>专用网：仅供某个组织内部使用的网络</li>
</ul>
</li>
<li>按传输介质分类：有线网络、无线网络</li>
</ul>
<h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>定义：指连接到网络上的节点在信道上传输数据的速率。也称<strong>数据率或比特率、数据传输速率</strong><br>单位：bits&#x2F;s,b&#x2F;s或者bps（比特每秒）(1B &#x3D; 8b)<em>以1000作为横跨单位</em><br>信道：表示某一方向传送信息的通道（信道<strong>不等于</strong>通信线路），一条信道线路在逻辑上往往对应一条发送信道和一条接受信道  </p>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>定义：某信道所能传送的最高数据率（其他含义：表示某信道允许通过的信号频带范围）<br>单位：bps（b&#x2F;s、bit&#x2F;s）</p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>定义：指单位时间内通过某个网络（或信道、接口）的实际数据量。<br>吞吐量受带宽限制、受复杂的网络负载情况影响</p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>定义：指数据（一个报文或分组，甚至比特）从网络的一端传送到另一端所需的时间。有时也被称为延迟或迟延<br><strong>总时延&#x3D;发送时延+传播时延+处理时延+排队时延</strong><br>传输（发送）时延：节点将数据推向信道所花时间 &#x3D;$\frac{数据长度(bit)}{发送速率(bit&#x2F;s)}$<br>传播时延：电磁波在信道中传播一定的距离所花的时间&#x3D;$\frac{信道长度（m）}{电磁波在洗脑中的传播速度（m&#x2F;s）}$<br>处理时延：被路由器处理所花的时间<br>排队时延：数据排队进入，排队发出路由器所花的时间<br><code>处理时延与排队时延受网络负载、路由器性能等诸多因素影响</code>  </p>
<h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p><em><strong>时延带宽积&#x3D;传播时延*带宽</strong></em><br>定义：一条链路中，已从发送端发出但尚未达到接收端的最大比特数</p>
<h3 id="往返时延"><a href="#往返时延" class="headerlink" title="往返时延"></a>往返时延</h3><p>（RTT）定义：表示从发送方发送完数据，到发送方收到来自接收方的确认总共经历的时间<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/RTT.png">  </p>
<h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p>定义：某个信道有百分之多少的时间是有数据通过的<br>信道利用率&#x3D;$\frac{有数据通过的时间}{有数据通过的时间+没有数据通过的时间}$<br><code>信道利用率太高说明网络拥塞；太低说明浪费资源</code></p>
<h2 id="计算机分层"><a href="#计算机分层" class="headerlink" title="计算机分层"></a>计算机分层</h2><p>ISO提出OSI参考模型（法律上的标准）：物理层、数据链路层、网络层、运输层、会话层、表示层、应用层；<br>ARPANET提出TCP&#x2F;IP模型：网络接口层、网际层、传输层、应用层<br><strong>教学用的模型：物理层、数据链路层、网络层、传输层、应用层</strong><br>网络的体系结构：计算机网络的各层及其协议的集合，就是这个计算机网络及其构件所应完成的精确定义<br><code>服务的作用方向为垂直的，协议的方向是水平的</code><br>协议数据单元（PDU）：对等层次之间传送的数据单位<br>服务数据单元（SDU）：为完成上一层实体所要求的功能而传送的数据<br>协议控制信息（PCI）：控制协议操作的信息<br>n-SDU+n-PCI &#x3D; n-PDU&#x3D;(n-1)-SDU<br>协议由语法、语义和同步三部分组成  </p>
<ul>
<li>语法：数据与控制信息的格式</li>
<li>语义：即需要发出何种控制信息、完成何种动作及做出何种应答。</li>
<li>同步：执行各种操作的条件、时序关系等，即事件实现顺序的详细说明。</li>
</ul>
<h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p>物理层任务：实现相邻节点之间的比特传输<br>链路层任务：确保相邻节点之间的链路逻辑上无差错（差错控制、流量控制、物理寻址）<br>网络层任务：把”分组“从源节点转发到目的节点（路由选择、分组转发、拥塞控制、网际互联、差错控制、流量控制、连接建立与释放、可靠传输管理······）<br>传输层任务：实现端到端通信（复用和分用）<br>会话层任务：管理进程间会话  （会话管理）<br>表示层任务：解决不同主机上信息表示不一致的问题  （数据格式转换）<br>应用层任务：实现特定的网络应用<br> <code>网络层向上层提供有连接可靠的服务（虚电路）无连接不可靠服务（数据报）</code><br> <code>OSI传输层向上提供有连接可靠的服务</code></p>
<h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h3><p>网络接口层：为网络层传输”分组“，<em>未具体描述网络接口层的功能、协议</em><br>应用层：将OSI模型中的会话层、表示层、应用层的任务集合在应用层中<br>网络层：路由选择、分组转发、拥塞控制、网际互联<br>传输层：复用和分用、差错控制、流量控制、连接建立与释放、可靠传输管理<br><code>网络层向上层提供无连接不可靠服务（数据报）</code><br> <code>TCP/IP传输层向上提供有连接可靠的服务（TCP）无连接不可靠服务（UDP）</code></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>服务访问点（SAP）：在同一系统中相邻两层的实体交换信息的逻辑接口。<em>用于区分不同的服务类型</em><br>数据链路层的SAP：<strong>帧的“类型”字段</strong><br>网络层的SAP：<strong>IP数据报的“协议”字段</strong><br>传输层的SAP：<strong>“端口号”字段</strong><br>应用层的SAP：<strong>“用户接口”</strong>  </p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>第二章-栈、队列和数组</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>定义：只允许在一端进行插入或删除操作的 <strong>线性表</strong><br><code>n个不同元素进栈，出战元素不同排列个数为</code>$\frac{1}{n+1}C_{2n}^n$</p>
<h4 id="顺序存储结构体"><a href="#顺序存储结构体" class="headerlink" title="顺序存储结构体"></a>顺序存储结构体</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MaxSize 50           //定义栈中元素的最大个数</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	Elemtype data[MaxSize];  //存放栈中元素</span><br><span class="line">	int top;                 //栈顶元素</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></div>
<p><code>后进先出（Last In First Out，LIFO）</code></p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>InitStack(&amp;S):初始化空栈</li>
<li>StackEmpty(S):判断栈是否为空，空返回true</li>
<li>Push(&amp;S,x)：进栈，若栈S未满，则将x加入使之成为新栈顶。</li>
<li>Pop(&amp;S,&amp;x)：岀栈，若栈S非空，则弹出栈顶元素，并用x返回。</li>
<li>GetTop (S, &amp;x):读栈顶元素，若栈S非空，则用x返回栈顶元素。</li>
<li>DestroyStack(&amp;S)：销毁栈，并释放栈S占用的存储空间</li>
</ul>
<h4 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h4><p>让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/shareStack.png"><br><code>共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满 时才发生上溢。</code></p>
<h4 id="链式存储结构体"><a href="#链式存储结构体" class="headerlink" title="链式存储结构体"></a>链式存储结构体</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct LinkNode&#123;</span><br><span class="line">	ElemType data;          //数据域</span><br><span class="line">	struct Linknode *next;  //指针域</span><br><span class="line">&#125;*LiStack;                  //栈类型定义</span><br></pre></td></tr></table></figure></div>
<p><code>链栈的优点是便于多个栈共享存储空间和提高其效率，且不存 在栈满上溢的情况。</code></p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>定义：只允许在表的一端进行插入，而在表的另一端进行删除的线性表。<br><code>先进先出（First In First Out，FIFO）</code><br><code>栈和队列具有相同的逻辑结构，都是线性表。</code>  </p>
<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>InitQueue (&amp;Q):初始化队列，构造一个空队列Q。</li>
<li>QueueEmpty (Q)：判队列空，若队列Q为空返回true,否则返回false。</li>
<li>EnQueue (&amp;Q, x)：入队，若队列Q未满，将x加入，使之成为新的队尾。</li>
<li>DeQueue (&amp;Q, &amp;x):岀队，若队列Q非空，删除队头兀素，并用x返回。</li>
<li>GetHead(Q,&amp;x)：读队头元素，若队列Q非空，则将队头元素赋值给x。</li>
</ul>
<h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MaxSize 50</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	ElemType data[MaxSize];  //用数组存放队列元素</span><br><span class="line">	int front,rear;          //队头指针和队尾指针</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure></div>
<p><strong>队列判空条件：Q.rear &#x3D;&#x3D; Q.front &#x3D;&#x3D; 0  但不能用Q.rear &#x3D;&#x3D; MaxSize</strong></p>
<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>定义：存储队列元素的表从逻辑上视为一个环<br><code>当队首指针Q.front=MaxSize-l后，再前进一个位置就自动到0,这可以利用除法取余运算(％)来实现。</code><br>队空条件：Q.front &#x3D;&#x3D; Q.rear<br>判断队空还是队满的处理方式：</p>
<ul>
<li>牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法, 约定以“队头指针在队尾指针的下一位置作为队满的标志”<ul>
<li>队满条件：(Q. rear+1) %MaxSize &#x3D;&#x3D; Q. fro nt。</li>
<li>队空条件仍：Q. front &#x3D;&#x3D; Q.rear。</li>
<li>队列中元素的个数：(Q. rear-Q.front+MaxSize) % MaxSize。</li>
</ul>
</li>
<li>类型中增设表示元素个数的数据成员。这样，队空的条件为Q. size&#x3D;&#x3D; 0；队满的条件为 Q. size &#x3D;&#x3D; MaxSize。这两种情况都有 Q. front &#x3D;&#x3D; Q.rear。</li>
<li>类型中增设tag数据成员，以区分是队满还是队空。tag等于0时，若因删除导致 Q. front &#x3D;&#x3D; Q. rear,则为队空；tag等于1时，若因插入导致Q. front &#x3D;&#x3D; Q. rear, 则为队满。</li>
</ul>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct LinkNode&#123;  //链式队列结点</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct LinkNode *next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line">typedef struct &#123;            //链式队列</span><br><span class="line">	LinkNOde *front,*rear;  //队列的对头和队尾指针</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure></div>
<p><code>用单链表表示的链式队列特别适合于数据元素变动比较 大的情形，而且不存在队列满且产生溢出的问题。</code></p>
<h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><p>定义：允许两端都可以进行入队和出队操作的队列。其元素的逻辑结构仍是线性结构。将队列的两端分别称为前端和后端，两端都可以入队和出队。</p>
<ul>
<li>输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为 输出受限的双端队列；</li>
<li>输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为 输入受限的双端队列</li>
</ul>
<h1 id="栈的括号匹配应用"><a href="#栈的括号匹配应用" class="headerlink" title="栈的括号匹配应用"></a>栈的括号匹配应用</h1><p>算法思路：</p>
<ol>
<li>初始设置一个空栈，顺序读入括号。</li>
<li>若是左括号，则存入栈中；</li>
<li>若是右括号，则先检查栈顶的括号是否于其匹配，若匹配，则弹栈；若不匹配，直接输出不合法；直到栈空。</li>
</ol>
<h1 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h1><p>基本思路：先将中缀表达式转换为后缀表达式，再对后缀表达式求值。</p>
<h2 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h2><ol>
<li>初始两个栈，一个栈op用于存储运算符号，一个栈存储后缀表达式</li>
<li>遍历中缀表达式<ol>
<li>遇到操作符，直接存入后缀表达式栈中；</li>
<li>遇到括号界限符，左括号直接加入操作符栈中，遇到右括号将操作符栈中的左括号以上的运算符依次弹出至后缀表达式栈中；</li>
<li>遇到操作符，比对栈顶运算符，如若栈顶运算符优先级更高（除括号界限符），则从栈顶开始，依此弹出栈中优先级高于或等于当前运算符的所有运算符至后缀表达式栈中，再将该运算符压入后缀表达式栈中；否则直接该运算符压入后缀表达式栈中。</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th align="right">待处理序列</th>
<th>op栈</th>
<th>后缀表达式</th>
<th>扫描项</th>
<th>操作说明</th>
</tr>
</thead>
<tbody><tr>
<td align="right">A+B*(C-D)-E&#x2F;F</td>
<td></td>
<td></td>
<td>A</td>
<td>A加入中缀表达式</td>
</tr>
<tr>
<td align="right">+B*(C-D)-E&#x2F;F</td>
<td></td>
<td>A</td>
<td>+</td>
<td>+压入op栈</td>
</tr>
<tr>
<td align="right">B*(C-D)-E&#x2F;F</td>
<td>+</td>
<td>A</td>
<td>B</td>
<td>B加入中缀表达式</td>
</tr>
<tr>
<td align="right">*(C-D)-E&#x2F;F</td>
<td>+</td>
<td>AB</td>
<td>*</td>
<td>*优先级高于栈顶，* 压入op栈</td>
</tr>
<tr>
<td align="right">(C-D)-E&#x2F;F</td>
<td>+*(</td>
<td>AB</td>
<td>(</td>
<td>(直接入栈</td>
</tr>
<tr>
<td align="right">C-D)-E&#x2F;F</td>
<td>+*(</td>
<td>AB</td>
<td>C</td>
<td>C加入中缀表达式</td>
</tr>
<tr>
<td align="right">-D)-E&#x2F;F</td>
<td>+*(</td>
<td>ABC</td>
<td>-</td>
<td>栈顶为(,-压入op栈</td>
</tr>
<tr>
<td align="right">D)-E&#x2F;F</td>
<td>+*(-</td>
<td>ABC</td>
<td>D</td>
<td>D加入中缀表达式</td>
</tr>
<tr>
<td align="right">)-E&#x2F;F</td>
<td>+*(-</td>
<td>ABCD</td>
<td>)</td>
<td>遇到)，弹出-，删除(</td>
</tr>
<tr>
<td align="right">-E&#x2F;F</td>
<td>+*</td>
<td>ABCD-</td>
<td>-</td>
<td>-优先级低于栈顶，依此弹出*、+，-加入中缀表达式</td>
</tr>
<tr>
<td align="right">E&#x2F;F</td>
<td>-</td>
<td>ABCD-*+</td>
<td>E</td>
<td>E加入中缀表达式</td>
</tr>
<tr>
<td align="right">&#x2F;F</td>
<td>-</td>
<td>ABCD-*+E</td>
<td>&#x2F;</td>
<td>&#x2F;优先级高于栈顶，&#x2F;压入op栈</td>
</tr>
<tr>
<td align="right">F</td>
<td>-&#x2F;</td>
<td>ABCD-*+E</td>
<td>F</td>
<td>F加入中缀表达式</td>
</tr>
<tr>
<td align="right"></td>
<td>-&#x2F;</td>
<td>ABCD-*+EF</td>
<td></td>
<td>扫描完毕，弹出op栈中所有元素</td>
</tr>
<tr>
<td align="right"></td>
<td></td>
<td>ABCD-*+EF&#x2F;-</td>
<td></td>
<td>结束</td>
</tr>
</tbody></table>
<h2 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h2><p><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/calculate.png"><br><code>队列在计算机系统的作用：第一个方面是解决主机与外部设备之间速度不匹配的问题，第二个方面是解决由多用户引起的资源竞争问题。</code></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><code>数组与线性表的关系：数组是线性表的推广</code></p>
<h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><p>一维数组A[0···n-1]存储结构关系式:$LOC(a_{i})&#x3D;LOC(a_0)+i*L (0 \leq i &lt; n)$<br>多维数组有两种映射方式：按行优先和按列优先</p>
<ul>
<li>按行优先：$LOC(a_{i,j})&#x3D;LOC(a_{0,0})+[i*(h+1)+j]*L (0 \leq i &lt; n)$</li>
<li>按列优先：$LOC(a_{i,j})&#x3D;LOC(a_{0,0})+[j*(h+1)+i]*L (0 \leq i &lt; n)$</li>
</ul>
<h2 id="压缩存储"><a href="#压缩存储" class="headerlink" title="压缩存储"></a>压缩存储</h2><ol>
<li>对称矩阵：上三角区元素与下三角区对应元素相等<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/cemetry_metrix.png"></li>
<li>三角矩阵：上三角区或者下三角区元素均为同一常量(图为下三角矩阵对应存储关系)<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/tringle_metrix.png"></li>
<li>三对角矩阵：对于n阶矩阵A中的任意一个元素$a_{i,j}$,当|i-j|&gt;1时，$a_{i,j}&#x3D;0$;由此得出对应的一维矩阵下标$k&#x3D;2*i+j-3$</li>
<li>稀疏矩阵：矩阵中非零元素的个数t，相对于矩阵元素的个数s来说非常少。对此，将非零元素及其相应的行和列构成一个三元组。<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/small_metrix.png"></li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>第三章-数据链路层</title>
    <url>/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<p>数据链路层使用“物理层”提供的“比特传输”服务<br>数据链路层为网络层提供服务，将网络层的IP数据报（分组）封装成帧，传输给下一个相邻节点<br><strong>物理链路</strong>：传输介质（0层）+物理层（1层）实现了相邻节点之间的“物理链路”<br><strong>逻辑链路</strong>：数据链路层需要基于“物理链路”，实现相邻结点之间逻辑上无差错的“数据链路”  </p>
<hr>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul>
<li>封装成帧：<ul>
<li>帧定界：如何让接收方能够确定帧的界限</li>
<li>透明传输：接收方链路层要能从收到的帧内恢复原始SDU，让网络层“感受不到”将分组封装成帧的过程</li>
</ul>
</li>
<li>差错控制：发现并解决一个帧内部的“位错”<ul>
<li>解决方案一：接收方发现比特错后丢弃帧，发送方重传帧（仅需采用检错编码）</li>
<li>解决方案二：由接收方发现并纠正比特错误（需采用纠错编码）</li>
</ul>
</li>
<li>可靠传输：发现并解决“帧错”（帧丢失、帧重复、帧失序）</li>
<li>流量控制：控制发送方发送帧的速率别太快，让接收方“来得及”接受</li>
<li>介质访问控制：<ul>
<li>“广播信道”需要实现此功能。广播信道在逻辑上是总线型拓扑，多个结点需争抢传输介质的使用权</li>
<li>“点对点信道”通常不需要实现此功能。点对点信道通常意味着两个节点之间有专属介质，不用抢</li>
</ul>
</li>
</ul>
<hr>
<h1 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h1><ul>
<li>字符计数法：在每个帧开头，用一个定长计数字段表示帧长<ul>
<li>缺点：任何一个技术字段出错，都会导致后续所有帧无法定界</li>
</ul>
</li>
<li>字节填充法：使用SOH和EOT控制字符表示一帧的开始与结束，通常会使用ESC转义字符避免帧中出现控制字符导致扫描出错。</li>
<li>零比特填充法（HDLC、PPP）：使用比特串01111110来标志一帧的开始和结束<ul>
<li>发送方需要对帧的数据部分进行处理，<em>每当遇到5个1，就填充一个0</em></li>
<li>接收方需要对帧的数据部分进行逆处理，<em>每当遇到连续5个1，就删掉后面的0</em></li>
</ul>
</li>
<li>违规编码法：需要物理层配合，对采用的信号传输方式使用违规的信号编码，例如基于曼彻斯特码，每一个信号是观察信号是否跳变，当信号不进行跳变时则“违规”，将其表示帧的开始或结束</li>
</ul>
<hr>
<h1 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h1><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>奇（偶）校验码：整个校验码（有效信息为何校验位）中“1”的个数为奇（偶）数<br>奇校验：检查信息位中“1”的个数为偶数则校验位为1，为奇数则检验位为0（偶校验相反）<br>偶校验的硬件实现：各信息进行异或运算，得到的结果即为偶校验位<br>缺点：只能检测奇数位出现错误的情况，并且不知道哪些位出错</p>
<h3 id="循环冗余码（CRC）"><a href="#循环冗余码（CRC）" class="headerlink" title="循环冗余码（CRC）"></a>循环冗余码（CRC）</h3><p>思想：数据发送、接收方约定为一个“除数”，K个信息位+R个校验位作为“被除数”，添加校验位后需保证出发的余数为0，然后接收方进行除法检测余数是否为0，非0即需要重传或者纠错<br>基本思想：</p>
<ol>
<li>收发双方约定生成多项式G(x)（最高位和最低位必须为1），k位位串可视为阶数为k-1的多项式的系数序列。例如，可用多项式$x^3+x^2+1$表示位串1101</li>
<li>发送方基于待发送的数据和G(x)，计算冗余码，将冗余码附加到数据后面一起发送</li>
<li>接收方收到数据和冗余码后，通过G(x)来计算收到的数据和冗余码是否产生差错</li>
</ol>
<p>检错能力：</p>
<ul>
<li>可检测出所有格奇数个错误</li>
<li>可检测出所有双比特的错误</li>
<li>可检测出所有小于等于检验位长度的连续错误</li>
<li>若选择合适的生成多项式，且$2^R\geq K+R+1$,则可纠正单比特错误</li>
</ul>
<h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><ol>
<li>确定海明码位数：n为有效信息位数，k为校验位的位数，则信息位n和校验位k应满足$n+k+1\leq2^k-1$</li>
<li>确定校验位的分布，校验位$P_i$放在海明位号为$2^{i-1}$的位置上，信息位按顺序放到其余位置</li>
<li>分组以形成校验关系：被检验数据位的海明位号等于检验该数据位的各检验位海明位号之和</li>
<li>检验位取值：检验位$P_i$的值为第i组所有位求异或</li>
<li>构造校验方程：G1 &#x3D; P1 ⊕ D1 ⊕ D2 ⊕ D4 ；G2 &#x3D; P2 ⊕ D1 ⊕ D3 ⊕ D4；G3 &#x3D; P3 ⊕ D2 ⊕ D3 ⊕ D4等，最后由“G3G2G1”的值进行判断，若为“000”，则正确，若为“001”，则第一位发生了错误</li>
</ol>
<p>综上所述，海明码纠错能力只有1位，检错能力可以检错2位<br>海明码“纠错”d位，需要码距2d+1的编码方案；“检错”d位，则只需码距为d+1  </p>
<hr>
<h1 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h1><p>$W_T+W_R\leq2^n$  </p>
<h2 id="停止等待协议（S-W）"><a href="#停止等待协议（S-W）" class="headerlink" title="停止等待协议（S-W）"></a>停止等待协议（S-W）</h2><p>原理：发送方每次只允许发送一个帧，接收方每接收一个帧都要反馈一个应答信号，表示可以接受下一帧，发送方收到应答信号后才能发送下一帧。若发送方没有收到接收方反馈的应答信号，则需要一直等待。发送方每发送完一个帧，就进入等待接收方确认信息的过程中，因而传输效率很低。<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/SW.png"></p>
<h2 id="后退N帧协议（GBN）"><a href="#后退N帧协议（GBN）" class="headerlink" title="后退N帧协议（GBN）"></a>后退N帧协议（GBN）</h2><p>在后退N帧协议中，发送方可在为收到确认帧的情况下，将序号在发送窗口内的多个数据帧全部发送出去。后退N帧的含义是：发送方发送N个数据帧后，若发现这N个帧的前一个数据帧在计时器超时的时候仍未收到其确认信息，则该帧被判为出错或丢失，此时发送方不得不重传该出错帧及随后的N个帧<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/GBN.png"></p>
<h2 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h2><p>选择重传协议：用于在不可靠的网络中进行可靠数据传输。它允许发送方同时发送多个数据包，并在接收方接收到这些数据包后进行选择性的重传。只有丢失或损坏的数据包会被重新传输，而不需要重新传输整个数据流。<code>存在帧缓冲区，用于维持帧的顺序位次</code>  </p>
<ol>
<li>发送方将数据分成多个数据包，并分配唯一的序列号给每个数据包。</li>
<li>发送方将这些数据包发送到接收方。</li>
<li>接收方接收数据包，并根据序列号将它们按顺序重组。</li>
<li>如果接收方检测到有丢失或损坏的数据包，它会向发送方发送一个选择性重传请求，请求重新发送仅丢失或损坏的数据包。</li>
<li>发送方收到选择性重传请求后，仅重新发送被请求的数据包。</li>
<li>这个过程不断重复，直到接收方成功接收所有数据包。</li>
</ol>
<hr>
<h1 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h1><h2 id="信道划分介质访问控制（MAC）：-将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网路上的设备。多路复用技术：把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源，提高信道利用率。分用：把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子信道，实际就是把广播信道转变为点对点信道。-频分多路复用（FDM）用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽资源。优点：充分利用传输介质带宽，系统效率较高；由于技术比较成熟，实现也比较容易。-时分多路复用（TDM）将时间划分为一段段等长的时分复用帧。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道。统计时分复用（STDM）：每一个STDM帧中的时隙数小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的输入缓存，然后集中按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中，一个STDM帧满了就可以发出。STDM帧不是固定分配时隙，而是按需动态分配时隙。-波分多路复用（WDM）光的频分多路复用，在一根光纤中传输多种不同波长的光信号，由于波长不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。-码分多路复用（CDM）码分多址（CDMA）：1个比特分为多个码片，每一个站点被指定一个唯一的m位的芯片序列。1-多个站点同时发送数据的时候，要求各个站点芯片序列相互正交，规格化内积为0-S·T-frac-1-m-sum-i-1-m-S-iT-i-0-2-两个向量到了公共信道，线性相加。-S-T3-数据分离：合并的数据和源站规格化内积-S·-S-T-1-T·-S-T-1"><a href="#信道划分介质访问控制（MAC）：-将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网路上的设备。多路复用技术：把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源，提高信道利用率。分用：把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子信道，实际就是把广播信道转变为点对点信道。-频分多路复用（FDM）用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽资源。优点：充分利用传输介质带宽，系统效率较高；由于技术比较成熟，实现也比较容易。-时分多路复用（TDM）将时间划分为一段段等长的时分复用帧。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道。统计时分复用（STDM）：每一个STDM帧中的时隙数小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的输入缓存，然后集中按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中，一个STDM帧满了就可以发出。STDM帧不是固定分配时隙，而是按需动态分配时隙。-波分多路复用（WDM）光的频分多路复用，在一根光纤中传输多种不同波长的光信号，由于波长不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。-码分多路复用（CDM）码分多址（CDMA）：1个比特分为多个码片，每一个站点被指定一个唯一的m位的芯片序列。1-多个站点同时发送数据的时候，要求各个站点芯片序列相互正交，规格化内积为0-S·T-frac-1-m-sum-i-1-m-S-iT-i-0-2-两个向量到了公共信道，线性相加。-S-T3-数据分离：合并的数据和源站规格化内积-S·-S-T-1-T·-S-T-1" class="headerlink" title="信道划分介质访问控制（MAC）：  将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网路上的设备。多路复用技术：把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源，提高信道利用率。分用：把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子信道，实际就是把广播信道转变为点对点信道。## 频分多路复用（FDM）用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽资源。优点：充分利用传输介质带宽，系统效率较高；由于技术比较成熟，实现也比较容易。## 时分多路复用（TDM）将时间划分为一段段等长的时分复用帧。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道。统计时分复用（STDM）：每一个STDM帧中的时隙数小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的输入缓存，然后集中按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中，一个STDM帧满了就可以发出。STDM帧不是固定分配时隙，而是按需动态分配时隙。## 波分多路复用（WDM）光的频分多路复用，在一根光纤中传输多种不同波长的光信号，由于波长不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。## 码分多路复用（CDM）码分多址（CDMA）：1个比特分为多个码片，每一个站点被指定一个唯一的m位的芯片序列。1. 多个站点同时发送数据的时候，要求各个站点芯片序列相互正交，规格化内积为0.     $S·T&#x3D;\frac{1}{m}\sum_{i&#x3D;1}^{m}S_iT_i&#x3D;0$2. 两个向量到了公共信道，线性相加。  S-T3. 数据分离：合并的数据和源站规格化内积$S·(S-T)&#x3D;1 \ T·(S-T)&#x3D;1$"></a>信道划分介质访问控制（MAC）：  将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网路上的设备。<br>多路复用技术：把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源，提高信道利用率。<br>分用：把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子信道，实际就是把广播信道转变为点对点信道。<br>## 频分多路复用（FDM）<br>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽资源。<br>优点：充分利用传输介质带宽，系统效率较高；由于技术比较成熟，实现也比较容易。<br>## 时分多路复用（TDM）<br>将时间划分为一段段等长的时分复用帧。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道。<br>统计时分复用（STDM）：每一个STDM帧中的时隙数小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的输入缓存，然后集中按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中，一个STDM帧满了就可以发出。STDM帧不是固定分配时隙，而是按需动态分配时隙。<br>## 波分多路复用（WDM）<br>光的频分多路复用，在一根光纤中传输多种不同波长的光信号，由于波长不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。<br>## 码分多路复用（CDM）<br>码分多址（CDMA）：1个比特分为多个码片，每一个站点被指定一个唯一的m位的芯片序列。<br>1. 多个站点同时发送数据的时候，要求各个站点芯片序列相互正交，规格化内积为0.     $S·T&#x3D;\frac{1}{m}\sum_{i&#x3D;1}^{m}S_iT_i&#x3D;0$<br>2. 两个向量到了公共信道，线性相加。  S-T<br>3. 数据分离：合并的数据和源站规格化内积$S·(S-T)&#x3D;1 \ T·(S-T)&#x3D;1$</h2><h1 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h1><h2 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h2><h2 id="纯ALOHA协议：不监听信道，不按时间槽发送，随机重发（如果发生冲突，接收方就会检测出差错，然后不予确认，发送方在一定时间内收不到就判断发生冲突，超时后等一随机时间在重传）时隙ALOHA协议：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送-纯ALOHA比时隙ALOHA吞吐量更低，效率更低-纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发-CSMA协议CS：载波监听，每一个站在发送数据之前以及发送数据时要检测一下总线上是否有其他计算机在发送数据。MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线。CSMA思想：发送帧之前，监听信道-1-坚持CSMA：如果一个主机要发送消息，那么它先监听信道，空闲则直接传输，不必等待；忙则一直监听，知道空闲马上传输。如果有冲突，则等待一个随机长的时间监听，重复上述过程。-优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。-假如有两个或两个以上的站点有数据要发送，冲突就不可避免。-非坚持CSMA：如果一个主机要发送消息，那么它先监听信道，空闲则直接传输，不必等待；忙则等待一个随机时间之后再进行监听-优点：采用随机的重发延迟时间可以减少冲突发生的可能性。-缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低。-p-坚持CSMA：如果一个主机要发送消息，那么它先监听信道，空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽在传输；忙则持续监听知道信道空闲再以p概率发送。若冲突则等到下一个时间槽开始在监听并重复上述过程。-优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间-缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费。-CSMA-CD（以太网）CD：碰撞检测，“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。（半双工网络）争用期：以太网的端到端往返时间2t截断二进制指数规避算法：1-确定基本退避时间为争用期2t2-定义参数k为重传次数，但k不超过10，即k-min【重传次数，10】-3-从离散的整数集合【0，1，···，-2-k-1-】中随机取出一个数r，重传所需要退避的时间就是r倍的基本退避时间，即2rt4-当重传达16次仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错最小帧长问题：帧的传输时延至少要两倍于信号在总线中的传播时延（最小帧长-总线传播时延-数据传输速率-2）-以太网规定最短帧长为64B-CSMA-CA（无线局域网）工作原理：-发送数据前，先检测信道是否空闲。-空闲则发出RTS，RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；信道忙则等待。-接收端收到RTS，将响应CTS。-发送端收到CTS后，开始发送数据帧（同时预约信道：发送方告知其他站点自己要传多久数据）-接收端收到数据帧后，将用CRC来检验数据是否正确，正确则响应ACK帧-发送方收到ACK就可以及逆行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用二进制指数退避算法来确定随机的推迟时间）"><a href="#纯ALOHA协议：不监听信道，不按时间槽发送，随机重发（如果发生冲突，接收方就会检测出差错，然后不予确认，发送方在一定时间内收不到就判断发生冲突，超时后等一随机时间在重传）时隙ALOHA协议：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送-纯ALOHA比时隙ALOHA吞吐量更低，效率更低-纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发-CSMA协议CS：载波监听，每一个站在发送数据之前以及发送数据时要检测一下总线上是否有其他计算机在发送数据。MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线。CSMA思想：发送帧之前，监听信道-1-坚持CSMA：如果一个主机要发送消息，那么它先监听信道，空闲则直接传输，不必等待；忙则一直监听，知道空闲马上传输。如果有冲突，则等待一个随机长的时间监听，重复上述过程。-优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。-假如有两个或两个以上的站点有数据要发送，冲突就不可避免。-非坚持CSMA：如果一个主机要发送消息，那么它先监听信道，空闲则直接传输，不必等待；忙则等待一个随机时间之后再进行监听-优点：采用随机的重发延迟时间可以减少冲突发生的可能性。-缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低。-p-坚持CSMA：如果一个主机要发送消息，那么它先监听信道，空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽在传输；忙则持续监听知道信道空闲再以p概率发送。若冲突则等到下一个时间槽开始在监听并重复上述过程。-优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间-缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费。-CSMA-CD（以太网）CD：碰撞检测，“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。（半双工网络）争用期：以太网的端到端往返时间2t截断二进制指数规避算法：1-确定基本退避时间为争用期2t2-定义参数k为重传次数，但k不超过10，即k-min【重传次数，10】-3-从离散的整数集合【0，1，···，-2-k-1-】中随机取出一个数r，重传所需要退避的时间就是r倍的基本退避时间，即2rt4-当重传达16次仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错最小帧长问题：帧的传输时延至少要两倍于信号在总线中的传播时延（最小帧长-总线传播时延-数据传输速率-2）-以太网规定最短帧长为64B-CSMA-CA（无线局域网）工作原理：-发送数据前，先检测信道是否空闲。-空闲则发出RTS，RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；信道忙则等待。-接收端收到RTS，将响应CTS。-发送端收到CTS后，开始发送数据帧（同时预约信道：发送方告知其他站点自己要传多久数据）-接收端收到数据帧后，将用CRC来检验数据是否正确，正确则响应ACK帧-发送方收到ACK就可以及逆行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用二进制指数退避算法来确定随机的推迟时间）" class="headerlink" title="纯ALOHA协议：不监听信道，不按时间槽发送，随机重发（如果发生冲突，接收方就会检测出差错，然后不予确认，发送方在一定时间内收不到就判断发生冲突，超时后等一随机时间在重传）时隙ALOHA协议：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送+ 纯ALOHA比时隙ALOHA吞吐量更低，效率更低+ 纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发## CSMA协议CS：载波监听，每一个站在发送数据之前以及发送数据时要检测一下总线上是否有其他计算机在发送数据。MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线。CSMA思想：发送帧之前，监听信道+ 1-坚持CSMA：如果一个主机要发送消息，那么它先监听信道，空闲则直接传输，不必等待；忙则一直监听，知道空闲马上传输。如果有冲突，则等待一个随机长的时间监听，重复上述过程。    + 优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。    + 假如有两个或两个以上的站点有数据要发送，冲突就不可避免。+ 非坚持CSMA：如果一个主机要发送消息，那么它先监听信道，空闲则直接传输，不必等待；忙则等待一个随机时间之后再进行监听    + 优点：采用随机的重发延迟时间可以减少冲突发生的可能性。    + 缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低。+ p-坚持CSMA：如果一个主机要发送消息，那么它先监听信道，空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽在传输；忙则持续监听知道信道空闲再以p概率发送。若冲突则等到下一个时间槽开始在监听并重复上述过程。    + 优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间    + 缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费。## CSMA&#x2F;CD（以太网）CD：碰撞检测，“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。（半双工网络）争用期：以太网的端到端往返时间2t截断二进制指数规避算法：1. 确定基本退避时间为争用期2t2. 定义参数k为重传次数，但k不超过10，即k&#x3D;min【重传次数，10】.3. 从离散的整数集合【0，1，···，$2^k-1$】中随机取出一个数r，重传所需要退避的时间就是r倍的基本退避时间，即2rt4. 当重传达16次仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错最小帧长问题：帧的传输时延至少要两倍于信号在总线中的传播时延（最小帧长&#x3D;总线传播时延*数据传输速率*2）,以太网规定最短帧长为64B## CSMA&#x2F;CA（无线局域网）工作原理：+ 发送数据前，先检测信道是否空闲。+ 空闲则发出RTS，RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；信道忙则等待。+ 接收端收到RTS，将响应CTS。+ 发送端收到CTS后，开始发送数据帧（同时预约信道：发送方告知其他站点自己要传多久数据）+ 接收端收到数据帧后，将用CRC来检验数据是否正确，正确则响应ACK帧+ 发送方收到ACK就可以及逆行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用二进制指数退避算法来确定随机的推迟时间）"></a>纯ALOHA协议：不监听信道，不按时间槽发送，随机重发（如果发生冲突，接收方就会检测出差错，然后不予确认，发送方在一定时间内收不到就判断发生冲突，超时后等一随机时间在重传）<br>时隙ALOHA协议：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送<br>+ 纯ALOHA比时隙ALOHA吞吐量更低，效率更低<br>+ 纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发<br>## CSMA协议<br>CS：载波监听，每一个站在发送数据之前以及发送数据时要检测一下总线上是否有其他计算机在发送数据。<br>MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线。<br>CSMA思想：<code>发送帧之前，监听信道</code><br>+ 1-坚持CSMA：如果一个主机要发送消息，那么它先监听信道，空闲则直接传输，不必等待；忙则一直监听，知道空闲马上传输。如果有冲突，则等待一个随机长的时间监听，重复上述过程。<br>    + 优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。<br>    + 假如有两个或两个以上的站点有数据要发送，冲突就不可避免。<br>+ 非坚持CSMA：如果一个主机要发送消息，那么它先监听信道，空闲则直接传输，不必等待；忙则等待一个随机时间之后再进行监听<br>    + 优点：采用随机的重发延迟时间可以减少冲突发生的可能性。<br>    + 缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低。<br>+ p-坚持CSMA：如果一个主机要发送消息，那么它先监听信道，空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽在传输；忙则持续监听知道信道空闲再以p概率发送。若冲突则等到下一个时间槽开始在监听并重复上述过程。<br>    + 优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间<br>    + 缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费。<br>## CSMA&#x2F;CD（以太网）<br>CD：碰撞检测，“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。（半双工网络）<br>争用期：以太网的端到端往返时间2t<br>截断二进制指数规避算法：<br>1. 确定基本退避时间为争用期2t<br>2. 定义参数k为重传次数，但k不超过10，即k&#x3D;min【重传次数，10】.<br>3. 从离散的整数集合【0，1，···，$2^k-1$】中随机取出一个数r，重传所需要退避的时间就是r倍的基本退避时间，即2rt<br>4. 当重传达16次仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错<br><strong>最小帧长问题：帧的传输时延至少要两倍于信号在总线中的传播时延（最小帧长&#x3D;总线传播时延*数据传输速率*2）,以太网规定最短帧长为64B</strong><br>## CSMA&#x2F;CA（无线局域网）<br>工作原理：<br>+ 发送数据前，先检测信道是否空闲。<br>+ 空闲则发出<strong>RTS</strong>，RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；信道忙则等待。<br>+ 接收端收到RTS，将响应<strong>CTS</strong>。<br>+ 发送端收到CTS后，开始发送数据帧（同时<strong>预约信道</strong>：发送方告知其他站点自己要传多久数据）<br>+ 接收端收到数据帧后，将用CRC来检验数据是否正确，正确则响应<strong>ACK帧</strong><br>+ 发送方收到ACK就可以及逆行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用二进制指数退避算法来确定随机的推迟时间）</h2><h1 id="轮询访问介质"><a href="#轮询访问介质" class="headerlink" title="轮询访问介质"></a>轮询访问介质</h1><p>信道划分介质访问控制（MAC）：</p>
<ul>
<li>基于多路复用技术划分资源</li>
<li>网络负载重：共享信道效率高，且公平</li>
<li>网络负载轻：共享信道效率低<br>随机访问MAC：</li>
<li>用户根据意愿随机发送信息，发送信息时可独占信道带宽</li>
<li>网络负载重：产生冲突开销</li>
<li>网络负载轻：共享信道效率高，单个节点可利用信道全部带宽<br>轮询访问MAC协议：</li>
<li>既要不产生冲突，又要发送时占全部带宽。</li>
</ul>
<h2 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h2><p>主节点轮流“邀请”从属结点发送数据</p>
<h2 id="令牌传递协议（物理星型拓扑，逻辑环形拓扑）"><a href="#令牌传递协议（物理星型拓扑，逻辑环形拓扑）" class="headerlink" title="令牌传递协议（物理星型拓扑，逻辑环形拓扑）"></a>令牌传递协议（物理星型拓扑，逻辑环形拓扑）</h2><p>令牌：一个特殊格式的MAC控制帧，不含任何信息。控制信道使用，确保同一时刻只有一个结点独占信道。<br><em>常用于负载较大、通信量较大的网络中</em>  </p>
<hr>
<h1 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h1><p>简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道。</p>
<ol>
<li>覆盖的地理范围较小，只在一个相对独立的局部范围内联</li>
<li>使用专门铺设的传输介质进行联网，数据传输速率高</li>
<li>通信延迟时间短，误码率低，可靠性较高</li>
<li>各站为平等关系，共享传输信道</li>
<li>多采用分布式控制和广播式通信，能进行广播和组播</li>
</ol>
<h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><p>主要存在：星型拓扑、总线型拓扑、环形拓扑、树型拓扑</p>
<ul>
<li>星型：传输速度快、便于控制和管理但网络可靠性低、网络共享能力差，有单点故障问题</li>
<li>总线型：可靠性高、网络节点响应速度快、共享资源能力强、设备投入量少、成本低、安装使用方便</li>
<li>环形：通信设备和线路比较节省，有单点故障问题，系统响应延时长，信息传输效率低</li>
<li>树型：易于拓展、易于隔离故障、容易单点故障</li>
</ul>
<h2 id="介质访问控制方法"><a href="#介质访问控制方法" class="headerlink" title="介质访问控制方法"></a>介质访问控制方法</h2><ol>
<li>CSMA&#x2F;CD：常用于总线型局域网，也用于树型网络</li>
<li>令牌总线：常用于总线型局域网，也用于树型网络。把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环。只有令牌持有者才能控制总线，才有发送信息的权力。</li>
<li>令牌环：用于环形局域网，如令牌环网</li>
</ol>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li>以太网：IEEE802.3</li>
<li>令牌环网：物理上是星型拓扑结构，逻辑上是环形拓扑结构（IEEE802.5）</li>
<li>FDDI网：物理上采用了双环拓扑结构，逻辑上是环形拓扑结构</li>
<li>ATM网：较新型的单元交换技术，使用53字节固定长度的单元进行交换</li>
<li>无线局域网：采用IEEE802.11标准</li>
</ol>
<h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>提供无连接、不可靠的服务。<strong>只实现无差错接受，不实现可靠传输</strong><br><em>以太网参考模型一般只包括物理层和数据链路层（网卡实现的主要功能在物理层和数据链路层）</em><br>10BASE-T是传送基带信号的双绞线以太网，T表示双绞线，传输速率是10Mb&#x2F;s，<strong>采用曼彻斯特编码，采用CSMA&#x2F;CD</strong><br>MAC地址：每个适配器有一个全球唯一的48位二进制地址，前24位代表厂家，后24位厂家自己制定<br>以太网V2MAC帧：<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/V2MAC.png"><br>高速以太网：100BASE-T以太网（全双工、半双工）、吉比特以太网（使用光纤传输、全双工、半双工）、10吉比特以太网<br>快速以太网仍然使用CSMA&#x2F;CD协议，采用保持最短帧长不变而将最大电缆长度减少提高数据传输速率</p>
<h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h3><p>802.11的MAC帧头格式：<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/80211MAC.png"></p>
<ul>
<li>有固定基础设施无线局域网</li>
<li>无固定基础设施无线局域网的自组织网络</li>
</ul>
<h2 id="MAC子层和LLC子层"><a href="#MAC子层和LLC子层" class="headerlink" title="MAC子层和LLC子层"></a>MAC子层和LLC子层</h2><p>IEEE802将数据链路层划分为逻辑链路层LLC子层和介质访问控制MAC子层<br>LLC：负责识别网络层协议，然后对他们进行封装。<br>MAC：数据帧的封装&#x2F;卸装，帧的寻址和识别，真的接受与发送，链路的管理，帧的差错控制等。  </p>
<h2 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h2><p>传统局域网的局限：</p>
<ul>
<li>缺乏流量隔离：即使把组流量局域划到一个单一交换机，广播流量仍会跨越整个机构网络</li>
<li>管理用户不便：如果一个主机在不同组件移动，必须改变物理布线，连接到新的交换机上。</li>
<li>路由器成本较高：局域网内使用很多路由器花销较大</li>
</ul>
<p>定义：VLAN是一种将局域网内的设备划分成与物理位置无关的逻辑组的局域网。每个VLAN是一个单独的广播域。<br>交换机上生成的各VLAN互不相通，若想实现通信，需要借助路由器、三层交换机。<br>VLAN标记的前两个字节表明是IEEE802.1Q帧，接下来4位没用，后面12位是VLAN标识符VID，唯一表示了该以太网帧属于哪个VLAN</p>
<ul>
<li>VID的取值范围是0<del>4095，表示VLAN的有效ID取值范围为1</del>4094</li>
<li>IEEE802.1Q帧是由交换机来处理的，而不是由用户主机来处理的（即主机和交换机之间酯交换普通的以太网帧）</li>
</ul>
<h1 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h1><p>通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，可以形成国际性的远程网络。<br>广域网的通信子网主要使用<strong>分组交换</strong>技术，广域网的通信子网可以利用公用分组交换网、卫星通信网和无限分组交换网，他将分布在不同地区的局域网或计算机系统互连起来，实现存储转发，达到<strong>资源共享</strong>的目的。</p>
<h2 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h2><p>只支持全双工链路，提供有连接不可靠服务  </p>
<ul>
<li>简单：对于链路层的帧，无需纠错，无需序号，无需流量控制</li>
<li>封装成帧：帧定界符</li>
<li>透明传输：与帧定界符一样比特组合的数据应该如何处理：异步线路用字节填充，同步线路用比特填充</li>
<li>多种网络层协议：封装的IP数据报可以采用多种协议</li>
<li>多种类型链路：串行&#x2F;并行，同步&#x2F;异步，电&#x2F;光</li>
<li>差错检测</li>
<li>检测连接状态</li>
<li>最大传送单元</li>
<li>网络层地址协商</li>
<li>数据压缩协商<br>无需满足的要求：</li>
<li>纠错</li>
<li>流量控制</li>
<li>序号</li>
<li>不支持多点线路<br>三个组成部分：</li>
<li>一个将IP数据报封装到串行链路的方法</li>
<li>链路控制协议LCP：建立并维护数据链路连接</li>
<li>网络控制协议NCP：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/PPP.png"></li>
</ul>
<table>
<thead>
<tr>
<th align="center">设备名称</th>
<th align="center">能否隔离冲突域</th>
<th align="center">能否隔离广播域</th>
</tr>
</thead>
<tbody><tr>
<td align="center">集线器</td>
<td align="center">不能</td>
<td align="center">不能</td>
</tr>
<tr>
<td align="center">中继器</td>
<td align="center">不能</td>
<td align="center">不能</td>
</tr>
<tr>
<td align="center">交换机</td>
<td align="center">能</td>
<td align="center">不能</td>
</tr>
<tr>
<td align="center">网桥</td>
<td align="center">能</td>
<td align="center">不能</td>
</tr>
<tr>
<td align="center">路由器</td>
<td align="center">能</td>
<td align="center">能</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<p>主要任务：把分组从源端传到目的端，为分布交换网上的不同主机提供通信服务。网络层传输单位是数据报。  </p>
<ul>
<li>路由选择与分组转发</li>
<li>异构网络互连</li>
<li>拥塞控制</li>
</ul>
<h1 id="SDN"><a href="#SDN" class="headerlink" title="SDN"></a>SDN</h1><p>数据平面（转发）：对于数据处理过程中各种具体处理转发过程。<br>控制平面（路由选择）：用于控制和管理网络协议的运行。<br>SDN：控制平面从路由器物理上分离。路由器仅实现转发，远程控制器计算和转发转发表以供每台路由器所使用。路由选择处理器负责与远程控制器通信，目的是接受远程控制器计算的转发表项。  </p>
<ul>
<li>SDN控制器：维护准确的网络状态信息（远程链路、路由器和主机的状态）；为运行在控制平面中的网络控制应用程序提供信息<ul>
<li>北向API：与网络控制应用程序交互。允许网络控制应用程序在状态管理层之间读写网络状态</li>
<li>网络范围状态管理层：由SDN控制平面作出的最终控制决定，将要求控制器具有有关网络的主机、链路等最新状态信息</li>
<li>通信层：SDN控制器与受控网络设备之间的通信（OpenFlow协议），包含“南向接口”</li>
</ul>
</li>
<li>网络控制应用程序：根据SDN控制器提供的方法，这些应用程序通过这些方法能够监视、编程和控制下面的网络设备</li>
</ul>
<h1 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h1><ul>
<li>静态路由算法：管理员手动配置路由信息<ul>
<li>优点：简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛应用于高度安全性的军事网络和较小的商业网络</li>
<li>缺点：路由更新慢，不使用大型网络</li>
</ul>
</li>
<li>动态路由算法（自适应路由算法）<ul>
<li>全局性（链路状态路由算法OSPF）：所有路由器掌握完整的网络拓扑和连路费用信息</li>
<li>分散性（距离向量路由算法RIP）：路由器只掌握物理相连的邻居及链路费用</li>
<li>优点：路由更新快，适用大型网络，及时响应链路费用或网络拓扑变化</li>
<li>缺点：算法复杂，增加网络负担</li>
</ul>
</li>
</ul>
<p>自治系统AS：在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由。<code>一个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通</code>  </p>
<ul>
<li>内部网关协议IGP：一个AS内使用的 （RIP、OSPF）</li>
<li>外部网关协议EGP：AS之间使用的（BGP）</li>
</ul>
<h2 id="RIP协议（UDP）"><a href="#RIP协议（UDP）" class="headerlink" title="RIP协议（UDP）"></a>RIP协议（UDP）</h2><p>RIP是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点是<em>简单</em>。<br>RIP协议要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录。<br>距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过路由器跳数+1.特别地，从一路由器到直接连接的网络距离为1.RIP允许一条路由最多只能包括15个路由器，因此距离为16表示<strong>网络不可达</strong>。  </p>
<ul>
<li>仅和相邻路由器交换信息</li>
<li>路由器交换的信息是自己的路由表</li>
<li>每30秒交换一次路由信息，然后路由器根据新信息更新路由表。若超过180s没收到邻居路由器的通告，则判定邻居没了并更新自己的路由表。</li>
</ul>
<p>更新路由表规则：</p>
<ul>
<li>若目的网络相同，且下一跳路由器相同，则直接更新</li>
<li>若是新的目的地址，则增加表项</li>
<li>若目的网络相同，则下一跳路由器不同，而距离更短，则更新</li>
<li>否则，无操作</li>
</ul>
<p><strong>好消息传得快，快消息传得慢</strong>  </p>
<h2 id="OSPF协议（IP）"><a href="#OSPF协议（IP）" class="headerlink" title="OSPF协议（IP）"></a>OSPF协议（IP）</h2><p>开放最短路径优先OSPF协议：“开放”标明OSPF不是受某一家厂商控制，而是公开发表的；使用的是Dijkstra提出的最短路径算法。  （每隔30min刷新；适用于大规模网络；收敛速度快）<br>OSPF将一个自治系统再划分为若干更小的范围，称为<em>区域</em>。划分区域的好处是，将利用洪泛法交换链路状态信息的范围局限在每个区域而非整个自治系统。<br>最主要的特征：使用分布式的链路状态协议。  </p>
<ul>
<li>使用洪泛式向自治系统内所有路由器发送信息，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器</li>
<li>发送的信息就是与本路由器相邻的所有路由器的链路状态（本路由器和那些路由器相邻，以及该链路的度量&#x2F;代价–费用、距离、时延、带宽等）</li>
<li>只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息</li>
</ul>
<h3 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h3><ol>
<li>每个路由器发现他的邻居结点【HELLO问候分组】，并了解邻居结点的网络地址。</li>
<li>设置到它的每个邻居的成本度量metric</li>
<li>构造【DD数据库描述分组】，相邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</li>
<li>如果DD分组中的摘要自己都有，则邻站不做处理；如果存在没有的或者是更新的，则发送【LSR链路状态请求分组】，请求自己没有的和比自己更新的信息。</li>
<li>收到邻站的LSR分组后，发送【LSU链路状态更新分组】进行更新</li>
<li>更新完毕后，邻站返回一个【LSAck链路状态确认分组】进行确认。</li>
</ol>
<p>只有一个路由器的链路状态发生变化：</p>
<ol>
<li>泛洪发送【LSU链路状态更新分组】进行更新</li>
<li>更新完毕后，其他站返回一个【LSAck链路状态确认分组】进行确认。</li>
<li>使用Dijkstar根据自己的链路状态数据库构造到其他节点间的最短路径。</li>
</ol>
<h2 id="BGP协议（应用层）（TCP）"><a href="#BGP协议（应用层）（TCP）" class="headerlink" title="BGP协议（应用层）（TCP）"></a>BGP协议（应用层）（TCP）</h2><p>和其他AS的邻站BGP发言人交换信息；交换网络可达性的信息，即要到达某个网络所要经过的一系列AS；发生变化时更新有变化的部分。  </p>
<ul>
<li>支持CIDR</li>
<li>发生变化时更新有变化的部分</li>
</ul>
<ol>
<li>OPEN报文：用来与相邻的另一个BGP发言人建立关系，并认证发送方</li>
<li>UPDATE报文：通告新路径或撤销原路径。</li>
<li>KEEPALIVE报文：在无UPDATE时，周期性证实邻站的连通性；也作为OPEN的确认。</li>
<li>NOTIFICTION报文：报告先前报文的差错；也被用于关闭连接<br><img lazyload src="/images/loading.svg" data-src="/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/Compare.png"></li>
</ol>
<h1 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h1><p><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/IP.png"><br>首部长度：<strong>以4B为单位</strong>，表示数据报中首部的长度<br>MTU：最大传送单元，链路层数据帧可封装数据的上限。以太网的MTU是1500字节。  </p>
<p>标识：同意数据报的分片使用统一标识。<br>标志：只有两位有意义，中间位DF：（DF&#x3D;1，禁止分片；DF&#x3D;0，允许分片）；最低位MF（MF&#x3D;1，后面还有“分片”；MF&#x3D;0，代表最后一片&#x2F;没分片）<br>片偏移：指出较长分组分片后，某片在原分组中的相对位置。<strong>以8B为单位</strong>。  </p>
<h1 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h1><p>IP地址：全世界唯一的32位&#x2F;4字节标识符，标识路由器主机的接口{&lt;网络号&gt;&lt;主机号&gt;}<br><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/IPv4.png"><br>特殊的IP地址</p>
<table>
<thead>
<tr>
<th>NetID（网络号）</th>
<th>HostID（主机号）</th>
<th>作为IP分组源地址</th>
<th>作为IP分组目的地址</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>全0</td>
<td>全0</td>
<td>可以</td>
<td>不可以</td>
<td>本网范围内表示主机，路由表中用于表示默认路由（表示整个Internet网络）</td>
</tr>
<tr>
<td>全0</td>
<td>特定值</td>
<td>可以</td>
<td>不可以</td>
<td>表示本网内某个特定主机</td>
</tr>
<tr>
<td>全1</td>
<td>全1</td>
<td>不可以</td>
<td>可以</td>
<td>本网广播地址（路由器不转发）</td>
</tr>
<tr>
<td>特定值</td>
<td>全0</td>
<td>不可以</td>
<td>不可以</td>
<td>网络地址，表示一个网络</td>
</tr>
<tr>
<td>特定值</td>
<td>全1</td>
<td>不可以</td>
<td>可以</td>
<td>直接广播地址，对特定网络上的所有主机进行广播</td>
</tr>
<tr>
<td>127</td>
<td>任何数</td>
<td>可以</td>
<td>可以</td>
<td>用于本地软件换回测试，称为环回地址</td>
</tr>
<tr>
<td>私有IP地址：</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>地址类别</th>
<th>地址范围</th>
<th>网段个数</th>
</tr>
</thead>
<tbody><tr>
<td>A类</td>
<td>10.0.0.0~10.255.255.255</td>
<td>1</td>
</tr>
<tr>
<td>B类</td>
<td>172.16.0.0~172.31.255.255</td>
<td>16</td>
</tr>
<tr>
<td>C类</td>
<td>192.168.0.0~192.168.255.255</td>
<td>256</td>
</tr>
<tr>
<td>常用的三种类别IP地址的使用范围：</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>网络类别</th>
<th>最大可用网络数</th>
<th>第一个可用的网络号</th>
<th>最后一个可用的网络号</th>
<th>每个网络的最大主机数</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>$2^7-2$</td>
<td>1</td>
<td>126</td>
<td>$2^{24}-2$</td>
</tr>
<tr>
<td>B</td>
<td>$2^{14}-1$</td>
<td>128.1</td>
<td>191.255</td>
<td>$2^{16}-2$</td>
</tr>
<tr>
<td>C</td>
<td>$2^{21}-1$</td>
<td>192.0.1</td>
<td>223.255.255</td>
<td>$2^8-2$</td>
</tr>
</tbody></table>
<h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>网络地址转换NAT：在专用网连接到因特网的路由器安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址。</p>
<h2 id="子网划分和子网掩码"><a href="#子网划分和子网掩码" class="headerlink" title="子网划分和子网掩码"></a>子网划分和子网掩码</h2><p>子网掩码：用来指明分类IP地址的主机号部分被借用了多少位作为子网号（与IP地址进行与运算）<br>路由器转发分组的算法：</p>
<ol>
<li>提取目的IP地址</li>
<li>是否直接交付</li>
<li>特定主机路由</li>
<li>检测路由表有无路径</li>
<li>默认路由0.0.0.0</li>
<li>丢弃，报告转发分组失败</li>
</ol>
<h2 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h2><p>CIDR把网络前缀都相同的连续的IP地址组成一个“CIDR地址块”<br>CIDR记法：IP地址后加上“&#x2F;”，然后写上网络前缀<br>特点：</p>
<ol>
<li>消除了传统的A类、B类和C类地址以及划分子网的概念</li>
<li>融合子网地址与子网掩码，方便子网划分</li>
</ol>
<p>将多个子网聚合成一个较大的子网，叫做路由聚合。方法：<code>将网络前缀缩短（所有网络地址取交集）</code><br>使用CIDR时，查找路由表可能得到几个匹配结果（跟网络掩码按位相与），应选择具有最长网络前缀的路由。前缀越长，地址块越小，路由越具体。  </p>
<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>ARP协议：完成主机或路由器IP地址到MAC地址的映射<br>四种典型情况：</p>
<ol>
<li>主机A发给本网络上的主机B：用ARP找到主机B的硬件地址</li>
<li>主机A发给另一网络上的主机B：用ARP找到本网络上一个路由器的硬件地址；</li>
<li>路由器发给本网络的主机A：用ARP找到主机A的硬件地址；</li>
<li>路由器发给另一网络的主机B：用ARP找到本网络上的一个路由器的硬件地址</li>
</ol>
<h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><p>动态主机配置协议DHCP是应用层协议，使用客户&#x2F;服务器方式，客户端和服务端通过广播方式进行交互，基于UDP。<br>DHCP提供即插即用联网机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址，允许地址重用，支持移动用户加入网络，支持在用地址续租。  </p>
<ol>
<li>主机广播DHCP发现报文</li>
<li>DHCP服务器广播DHCP提供报文</li>
<li>主机广播DHCP请求报文</li>
<li>DHCP服务器广播DHCP确认报文</li>
</ol>
<h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><h3 id="ICMP差错报文"><a href="#ICMP差错报文" class="headerlink" title="ICMP差错报文"></a>ICMP差错报文</h3><ul>
<li>终点不可达：当路由器或主机不能交付数据报时就像源点发送终点不可达报文。</li>
<li>源点抑制报文：当路由器或主机由于拥塞而丢弃数据报时，就像源点发送源点抑制报文，使源点知道应当把数据报的发送速率变慢。拥塞丢数据。</li>
<li>时间超过：当路由器收到生存时间TTL&#x3D;0的数据报时，除丢弃该数据报外，还要向远点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li>
<li>参数问题：当路由器或目的主机收到的数据报的首部中有的字段值不正确时，就丢弃该数据包，并向源点发送参数问题报文。</li>
<li>改变路由：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器。</li>
</ul>
<h3 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h3><ul>
<li>回送请求和回答报文：测试目的站是否可达以及了解其相关状态</li>
<li>时间戳请求和回答报文：用来进行时钟同步和测量时间</li>
<li>掩码地址请求和回答报文</li>
<li>路由器询问和通告报文</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>PING：测试两个主机之间的连通性，使用了ICMP回送请求和回答报文<br>Traceroute：跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文。</p>
<h1 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h1><p><img lazyload src="/images/loading.svg" data-src="/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/IPv6.png"><img lazyload src="/images/loading.svg" data-src="/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/IPv6-%E6%95%B0%E6%8D%AE%E6%8A%A5.png"></p>
<ul>
<li>版本：IPv6对应的是6</li>
<li>流标号：“流”是互联网络上从特定源点到特定终点的一系列数据报。所有属于同一个流的数据包具有同样的流标签</li>
<li>有效载荷长度：指明IPv6数据报除基本首部以外的字节数。</li>
<li>下一个首部：标识下一个扩展首部或上层协议首部</li>
<li>通信量类：区分不同的IPv6数据报的类别和优先级</li>
</ul>
<p><strong>IPv6和IPv4的区别：</strong></p>
<ul>
<li>IPv6将地址从32位扩大到128位，更大的地址空间</li>
<li>IPv6将IPv4的校验和字段彻底移除，以减少每跳的处理时间</li>
<li>IPv6将IPv4的可选字段移除首部，变成了扩展首部，称为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率</li>
<li>IPv6支持即插即用，不需要DHCP协议</li>
<li>IPv6首部长度必须是8B的整数倍，IPv4首部是4B的整数倍</li>
<li>IPv6只能在主机处分片，IPv4可以在路由器和主机处分片</li>
<li>ICMIPv6：附加报文类型“分组过大”</li>
<li>IPv6取消了协议字段，改成了下一个首部字段</li>
<li>IPv6支持资源的预分配，支持实时视像等要求，保证一定的带宽和时延的应用</li>
<li>IPv6取消了总长度字段，改用了有效载荷长度字段。</li>
<li>IPv6取消了服务类型字段。</li>
</ul>
<p>基本地址类型：</p>
<ul>
<li>单播：一对一通信，可做源地址+目的地址</li>
<li>多播：一对多通信，可做目的地址</li>
<li>任播：一对多中的一个通信，可做目的地址</li>
</ul>
<p>IPv6向IPv4过渡的策略：</p>
<ul>
<li>双栈协议：同时启用IPv4协议栈和IPv6协议栈</li>
<li>隧道技术：将其他协议的数据报重新封装然后通过隧道发送</li>
</ul>
<h1 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h1><p>IP组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将分配一个组播组IP地址（一群共同需求主机的相同标识）<br>组播地址范围为224.0.0.0~239.255.255.255（D类地址），一个D类地址表示一个组播组。只能用作分组的<strong>目标地址</strong>。源地址总是为单播地址。</p>
<ul>
<li>组播数据包不提供可靠交付，应用于UDP</li>
<li>对组播数据包不产生ICMP差错报文</li>
<li>并非所有D类地址都可以作为组播地址</li>
</ul>
<p>硬件组播：组播IP地址也需要相应的组播MAC地址在本地网络中实际传送帧。组播MAC地址以十六进制值01-00-5E打头，余下的6个十六机制位是根据IP组播组地址的最后23位转换得来的。<br>TCP&#x2F;IP协议使用的以太网多播地址范围是01-00-5E-00-00-00到01-00-5E-7F-FF-FF  </p>
<ul>
<li>网际组管理协议IGMP：让路由器知道本局域网上是否有主机参加或退出了某个组播组</li>
<li>组播路由选择协议：找出以源主机为根节点的<em>多播转发树</em></li>
</ul>
<h1 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h1><p>移动IP技术是移动结点以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证基于网络IP的网络权限再漫游过程中不发生任何改变。<br>移动节点：具有永久IP地址的移动设备。<br>归属代理（本地代理）：一个移动节点的永久“居所”称为归属网络，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理。<br>永久地址：移动站点在归属网络中的原始地址。<br>外部代理：在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理。<br>转交地址：可以是外部代理的地址或动态配置的一个地址。</p>
<h1 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h1><p>路由器：一种具有多个输入输出端口和多个输出端口的专用计算机，其任务是分组转发，互联两个不同网络层协议的网段。（可以隔离冲突域和广播域）<br>路由表是根据路由选择算法得出的，主要用途是路由选择，总用软件来实现。<br>转发表由路由表得来的，可以用软件实现，也可以用特殊的硬件来实现。  </p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>第五章-传输层</title>
    <url>/2024/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<p><em>只有主机才有的层次</em><br>功能：</p>
<ul>
<li>提供进程和进程之间的逻辑通信</li>
<li>复用和分用</li>
<li>对收到的报文进行差错检测</li>
<li>传输层的两种协议（TCP、UDP）</li>
</ul>
<p>复用：应用层所有的应用进程都可以通过传输层在传输到网络层<br>分用：传输层从网络层收到数据后指明的应用程序<br>端口：传输层的SAP，标识主机中的应用进程（逻辑端口&#x2F;软件端口）。端口号只有本地意义，在因特网中不同计算机的相同端口号是没有联系的  </p>
<ul>
<li>服务端使用的端口号<ul>
<li>熟知端口号：给TCP&#x2F;IP最重要的一些应用程序，让所有用户都知道（0~1023）</li>
<li>登记端口号：为没有熟知端口号的应用程序使用的（1024~49151）</li>
</ul>
</li>
<li>客户端使用：仅在客户进程运行时才动态选择的端口号（49152~65535）<br><img lazyload src="/images/loading.svg" data-src="/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/acknowledged_pot.png"><br>套接字：唯一标识网络中的一个主机和它上面的一个进程（主机IP地址，端口号）</li>
</ul>
<hr>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>UDP只在IP数据报服务之上增加很少功能，即复用分用和差错检测功能</p>
<ul>
<li>UDP是无连接的，减少开销和发送数据之前的时延</li>
<li>UDP使用最大努力交付，即不保证可靠交付</li>
<li>UDP是面向报文的，适合一次性传输少量数据的网络应用</li>
<li>UDP无拥塞控制，适合很多实时应用</li>
<li>UDP首部开销小，8B，TCP20B<br><img lazyload src="/images/loading.svg" data-src="/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/UDP.png"><br><img lazyload src="/images/loading.svg" data-src="/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/UDP_IP.png"><br>伪首部只有在计算校验和时才出现，不想下传送也不向上递交。<br>17：封装UDP报文的IP数据报首部协议字段时17.</li>
</ul>
<hr>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><ul>
<li>TCP是面向连接（虚连接）的传输层协议</li>
<li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的</li>
<li>TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达。</li>
<li>提供全双工通信。<ul>
<li>发送缓存：准备发送的数据&amp;已发送但尚未收到确认的数据</li>
<li>接受缓存：按序到达但尚未被接受应用程序读取的数据&amp;不按序到达的数据</li>
</ul>
</li>
<li>TCP面向字节流：TCP把应用程序交下来的数据堪称仅仅是一连串的无结构字节流<br><img lazyload src="/images/loading.svg" data-src="/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/TCP.png">序号（seq）：在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段标识本报文段所发送数据的第一个字节的序号。<br>确认号（<strong>小写ack</strong>）：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明到序号N-1为止的所有数据都已正确收到。<br>数据偏移（首部长度）：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B为单位，即一个数值是4B。<br><em>紧急位URG</em>：URG&#x3D;1时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。<br><em>确认位ACK</em>：ACK&#x3D;1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1.<br><em>推送位PSH</em>：PSH&#x3D;1时，接收方尽快交付接受应用进程，不再等到缓存填满再向上交付。<br><em>复位RST</em>：RST&#x3D;1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。<br><em>同步位SYN</em>：SYN&#x3D;1时，表明是一个连接请求&#x2F;连接接收报文。<br><em>终止位FIN</em>：FIN&#x3D;1时，表明此报文段发送方数据已发送完，要求释放连接。<br>窗口：指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。<br>校验和：校验首部+数据，检验时要加上12B伪首部，第四个字段为6.<br>紧急指针：URG&#x3D;1时才有意义，指出本报文段中紧急数据的字节数。<br>选项：最大报文段长度MSS、窗口扩大、时间戳、选择确认······</li>
</ul>
<h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><p>TCP连接的建立采用客户服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器。<br><em><strong>“三次握手”</strong></em>：<br><img lazyload src="/images/loading.svg" data-src="/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/three_shake.png"><br>SYN洪范攻击：攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。<br><em><strong>“四次握手”</strong></em>：<br><img lazyload src="/images/loading.svg" data-src="/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/four_shake.png"></p>
<h2 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h2><p>可靠：保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的。<br>重传：确认重传不分家，TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段。<br>冗余ACK：每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序号。  </p>
<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>流量控制：让发送方慢点，要让接收方来得及接受。（TCP利用滑动窗口机制实现流量控制）<br>在通信过程中，接收方根据自己接受缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的发送窗口取接受窗口rwnd和拥塞窗口cwnd的最小值。<br>TCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段。接收方收到探测报文段。接收方收到探测报文段时给出现在的窗口值。若窗口仍然是0，那么发送方就重新设置持续计时器。  </p>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><p><img lazyload src="/images/loading.svg" data-src="/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/slow_start.png">  </p>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p><img lazyload src="/images/loading.svg" data-src="/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/swift_recover.png"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>第二章-物理层</title>
    <url>/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<p>任务：实现相邻节点之间的比特（0或1）的传输</p>
<h2 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h2><ul>
<li>信源：信号的来源  </li>
<li>信宿：信号的“归宿”</li>
<li>数据：信息的实体</li>
<li>信道：信号的通道  </li>
<li>信号：<ul>
<li>数字信号：离散的</li>
<li>模拟信号：连续的</li>
</ul>
</li>
<li>码元：对应一种信号 <strong>1码元&#x3D;$log_{2}K$bit</strong></li>
<li>码元宽度：信号周期</li>
<li>波特率：每秒钟传输的码元数码元&#x2F;秒</li>
</ul>
<h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><p>奈奎斯特定理：<em><strong>对于一个理想低通信道（没有噪声、带宽有限的信道）</strong></em> 极限波特率&#x3D;2W（波特即码元&#x2F;秒）即**极限波特率&#x3D;$2Wlog_{2}K$**【W为带宽】  </p>
<ul>
<li>如果波特率太高，会导致“码间串扰”，即接收方无法识别码元</li>
<li>带宽越大，信道传输码元的能力越强</li>
<li>并未对一个码元最多可以携带多少比特做出解释</li>
</ul>
<p>香农定理：<em><strong>对于一个有噪声、带宽有限的信道</strong></em>，极限比特率&#x3D;W$log_{2}(1+\frac{S}{N})$  (b&#x2F;s)<br>信噪比&#x3D;S&#x2F;N&#x3D;$\frac{噪声的功率}{信号的功率}$&#x3D;10$log_{10}S&#x2F;N$(db分贝)</p>
<ul>
<li>提升信道带宽、加强信号功率、降低噪声功率，都可以提高信道的极限比特率</li>
<li>在带宽、信噪比确定的信道上，一个码元可以携带的比特数是有上限的</li>
</ul>
<h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><h3 id="数据编码转换为数字信号（编码）"><a href="#数据编码转换为数字信号（编码）" class="headerlink" title="数据编码转换为数字信号（编码）"></a>数据编码转换为数字信号（编码）</h3><ul>
<li>不归零编码（NRZ）：低0高1，中不变（没有自同步能力，不浪费带宽，抗干扰能力弱）</li>
<li>归零编码（RZ）：低0高1，中归0（有自同步能力，浪费带宽，抗干扰能力弱）</li>
<li>反向非归零编码（NRZI）：跳0不跳1看起点，中不变（若增加冗余位，可支持自同步，会浪费一点带宽，抗干扰能力弱）</li>
<li>曼彻斯特编码：跳0反跳1看中间，中必变（有自同步能力，浪费带宽，抗干扰能力强） <em>以太网常用曼彻斯特编码</em></li>
<li>差分曼彻斯特编码：跳0不跳1看起点，中必变 （有自同步能力，浪费带宽，抗干扰能力强）</li>
</ul>
<h3 id="数字数据转换为模拟信号（调制）"><a href="#数字数据转换为模拟信号（调制）" class="headerlink" title="数字数据转换为模拟信号（调制）"></a>数字数据转换为模拟信号（调制）</h3><ul>
<li>调幅（AM或ASK）：通过改变载波的振幅来表示数字0或1</li>
<li>调频（FM或FSK）：通过改变载波的频率来表示数字信号1和0</li>
<li>调相（PM或PSK）：通过改变载波的相位来表示数字1和0</li>
<li>正交幅度调制（QAM）：在频率相同的前提下，将AM与PM结合起来，形成叠加信号。设波特率为B，采用m个相位，每个相位有n种振幅则数据传输速率R为$R&#x3D;Blog_{2}mn$</li>
</ul>
<h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2><p><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/%E5%8F%8C%E7%BB%9E%E7%BA%BF.png"><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86.png"><img lazyload src="/images/loading.svg" data-src="/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/%E5%85%89%E7%BA%A4.png"></p>
<ul>
<li>10Base5——10Mbps,同轴电缆,最远传输距离500m</li>
<li>10BaseF*——10Mbps,光纤。*可以是其他信息</li>
<li>10BaseT*——10Mbps，双绞线。*可以是其他信息</li>
</ul>
<h3 id="无线传输介质"><a href="#无线传输介质" class="headerlink" title="无线传输介质"></a>无线传输介质</h3><ul>
<li>无线电波：穿透能力强、传输距离长、信号指向性弱（手机信号、WiFi）</li>
<li>微波通信：频率带宽高、信号指向性强、保密性差（卫星通信）</li>
<li>红外通信、激光通信等（信号指向性强）</li>
</ul>
<h3 id="物理层接口特性"><a href="#物理层接口特性" class="headerlink" title="物理层接口特性"></a>物理层接口特性</h3><ul>
<li>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等</li>
<li>电气特性：指明在接口电缆的各条线上出现的电压的范围、传输速率、距离限制等</li>
<li>功能特性：指明某条线上出现的某一点平的电压的意义</li>
<li>过程特性：指明对于不同功能的各种可能时间的出现顺序</li>
</ul>
<h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><p>中继器：中继器只有两个端口。通过一个端口接收信号，将失真信号整形再生，并转发至另一个端口，<em>仅支持半双工通信</em>，两个端口对应两个“网段”<br>集线器：本质上是多端口中继器。集线器将其中一个端口接收到的信号整形再生后，转发到其他端口，各端口连接的结点不可同时发送数据，会导致“冲突”，集线器的N个端口对应N个“网段”，各网段属于同一个“冲突域”  </p>
<ul>
<li>集线器、中继器不能无线串联</li>
<li>集线器连接的网络，物理上是星型拓扑，逻辑上是总线型拓扑</li>
<li>集线器链接的各网段“共享带宽”</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
</search>
